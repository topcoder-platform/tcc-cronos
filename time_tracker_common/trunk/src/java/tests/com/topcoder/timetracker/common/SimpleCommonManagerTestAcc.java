/*
 * Copyright (C) 2007 TopCoder Inc., All Rights Reserved.
 */
package com.topcoder.timetracker.common;

import java.util.Date;

import com.topcoder.timetracker.common.persistence.DatabasePaymentTermDAO;

/**
 * <p>
 * Accuracy tests for <code>SimpleCommonManager</code>.
 * All constructors and public methods are tested.
 * </p>
 *
 * @author TCSDEVELOPER
 * @version 3.1
  */
public class SimpleCommonManagerTestAcc extends BaseTestCase {

    /**
     * <p>
     * Assert the given <code>SimpleCommonManager</code>.
     * </p>
     *
     * @param manager The <code>SimpleCommonManager</code> to assert.
     * @param recentDays The expected recent days.
     *
     * @throws Exception to JUnit
     */
    private void assertManager(SimpleCommonManager manager, int recentDays) throws Exception {
        assertNotNull("The SimpleCommonManager should be instantiated", manager);
        assertTrue("The type of dao should be DatabasePaymentTermDAO",
                this.getField(manager, "paymentTermDAO") instanceof DatabasePaymentTermDAO);
        assertEquals("The recent Days should be " + recentDays,
                new Integer(recentDays), (Integer) this.getField(manager, "recentDays"));
    }
    /**
     * <p>
     * Test constructor <code>SimpleCommonManager()</code>.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testSimpleCommonManager() throws Exception {
        this.assertManager(this.getManager(), 3);
    }

    /**
     * <p>
     * Test constructor <code>SimpleCommonManager(String)</code>.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testSimpleCommonManagerString() throws Exception {
        this.assertManager(new SimpleCommonManager(SimpleCommonManager.class.getName()), 3);
        this.assertManager(new SimpleCommonManager("SimpleCommonManager"), -1);
    }

    /**
     * <p>
     * Test constructor <code>SimpleCommonManager(PaymentTermDAO, int)</code>.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testSimpleCommonManagerPaymentTermDAOInt() throws Exception {
        this.assertManager(new SimpleCommonManager(this.getDao(), 3), 3);
    }

    /**
     * <p>
     * Test accuracy of ctor <code>addPaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The <code>PaymentTerm</code> to be added is with id -1(the initial value), it will be ignored and replaced
     * by the id generated by <code>IDGenerator</code>.
     * </p>
     *
     * <p>
     * The creation date is null. It should be ignored and set as current date.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testAddPaymentTerm1() throws Exception {
        this.setupDB();
        PaymentTerm paymentTermToBeAdded = this.getPaymentTermWithOutId();

        paymentTermToBeAdded.setCreationDate(null);

        SimpleCommonManager manager = this.getManager();
        manager.addPaymentTerm(paymentTermToBeAdded);

        //The creation date and modification date should equal
        assertEquals("The creation date and modification date should equal",
               paymentTermToBeAdded.getCreationDate(), paymentTermToBeAdded.getModificationDate());

        //Note the next_block_start is 11, so 11 is generated here
        assertEquals("The id should be 11", 11, paymentTermToBeAdded.getId());

        assertFalse("Changed status should be false", paymentTermToBeAdded.isChanged());
        PaymentTerm addedPaymentTerm = manager.retrievePaymentTerm(paymentTermToBeAdded.getId());
        this.assertPaymentTermEquals(paymentTermToBeAdded, addedPaymentTerm);
    }

    /**
     * <p>
     * Test accuracy of ctor <code>addPaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The <code>PaymentTerm</code> to be added is with id -5, it will be ignored and replaced
     * by the id generated by <code>IDGenerator</code>.
     * </p>
     *
     * <p>
     * The modification date is null. It should be ignored and set as current date.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testAddPaymentTerm2() throws Exception {
        this.setupDB();
        PaymentTerm paymentTermToBeAdded = this.getPaymentTermWithId(-5);
        paymentTermToBeAdded.setModificationDate(null);

        SimpleCommonManager manager = this.getManager();
        manager.addPaymentTerm(paymentTermToBeAdded);

        //The creation date and modification date should equal
        assertEquals("The creation date and modification date should equal",
               paymentTermToBeAdded.getCreationDate(), paymentTermToBeAdded.getModificationDate());

        //Note the block_size is 3, so 12 is generated here
        assertEquals("The id should be 12", 12, paymentTermToBeAdded.getId());
        assertFalse("Changed status should be false", paymentTermToBeAdded.isChanged());
        PaymentTerm addedPaymentTerm = manager.retrievePaymentTerm(paymentTermToBeAdded.getId());
        this.assertPaymentTermEquals(paymentTermToBeAdded, addedPaymentTerm);
    }

    /**
     * <p>
     * Test accuracy of ctor <code>addPaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The <code>PaymentTerm</code> to be added is with id 5, it will be ignored and replaced
     * by the id generated by <code>IDGenerator</code>.
     * </p>
     *
     * <p>
     * The creation date exceeds modification date. It should be ignored and set to current date.
     * </p>
     *
     * <p>
     * The modification user is null. It should be ignored and set as the creation user.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testAddPaymentTerm3() throws Exception {
        this.setupDB();
        PaymentTerm paymentTermToBeAdded = this.getPaymentTermWithId(5);

        paymentTermToBeAdded.setModificationUser(null);
        paymentTermToBeAdded.setCreationDate(new Date(new Date().getTime() + ONEDAY));

        SimpleCommonManager manager = this.getManager();
        manager.addPaymentTerm(paymentTermToBeAdded);

        assertEquals("The creation user and modification user should equal",
               paymentTermToBeAdded.getCreationUser(), paymentTermToBeAdded.getModificationUser());
        //The creation date and modification date should equal
        assertEquals("The creation date and modification date should equal",
               paymentTermToBeAdded.getCreationDate(), paymentTermToBeAdded.getModificationDate());

        //Note the block_size is 3, so 13 is generated here.
        //But after these 3 times id generation, IDGenerator will query DB again
        //and find that the next_block_start is 11 again
        assertEquals("The id should be 13", 13, paymentTermToBeAdded.getId());
        assertFalse("Changed status should be false", paymentTermToBeAdded.isChanged());
        PaymentTerm addedPaymentTerm = manager.retrievePaymentTerm(paymentTermToBeAdded.getId());
        this.assertPaymentTermEquals(paymentTermToBeAdded, addedPaymentTerm);
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new description equals to the previous value, so no updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm1() throws Exception {
        this.setupDB();
        SimpleCommonManager manager = this.getManager();

        PaymentTerm previousPaymentTerm = manager.retrievePaymentTerm(1);
        //"desc1" equals to the previous value of description
        previousPaymentTerm.setDescription("desc1");

        //delete it
        manager.deletePaymentTerm(1);

        //Since the changed status of previousPaymentTerm is false, no updating will be performed
        //So no PaymentTermNotFoundException will be thrown here.
        manager.updatePaymentTerm(previousPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new active status equals to the previous value, so no updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm2() throws Exception {
        SimpleCommonManager manager = this.getManager();

        PaymentTerm previousPaymentTerm = manager.retrievePaymentTerm(1);
        //"true" equals to the previous value of active
        previousPaymentTerm.setActive(true);

        //delete it
        manager.deletePaymentTerm(1);

        //Since the changed status of previousPaymentTerm is false, no updating will be performed
        //So no PaymentTermNotFoundException will be thrown here.
        manager.updatePaymentTerm(previousPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new term equals to the previous value, so no updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm3() throws Exception {
        SimpleCommonManager manager = this.getManager();

        PaymentTerm previousPaymentTerm = manager.retrievePaymentTerm(1);
        //"1" equals to the previous value of term
        previousPaymentTerm.setTerm(1);

        //delete it
        manager.deletePaymentTerm(1);

        //Since the changed status of previousPaymentTerm is false, no updating will be performed
        //So no PaymentTermNotFoundException will be thrown here.
        manager.updatePaymentTerm(previousPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new description does not equal to the previous value,
     * but changed status is set as false explicitly, so no updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm4() throws Exception {
        SimpleCommonManager manager = this.getManager();

        PaymentTerm previousPaymentTerm = manager.retrievePaymentTerm(1);
        //"newDesc" does not equal to the previous value of description, but changed status is set as false explicitly
        previousPaymentTerm.setDescription("newDesc");
        previousPaymentTerm.setChanged(false);

        //delete it
        manager.deletePaymentTerm(1);

        //Since the changed status of previousPaymentTerm is false, no updating will be performed
        //So no PaymentTermNotFoundException will be thrown here.
        manager.updatePaymentTerm(previousPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new active status does not equal to the previous value,
     * but changed status is set as false explicitly, so no updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm5() throws Exception {
        SimpleCommonManager manager = this.getManager();

        PaymentTerm previousPaymentTerm = manager.retrievePaymentTerm(1);
        //"false" does not equal to the previous value of active, but changed status is set as false explicitly
        previousPaymentTerm.setActive(false);
        previousPaymentTerm.setChanged(false);

        //delete it
        manager.deletePaymentTerm(1);

        //Since the changed status of previousPaymentTerm is false, no updating will be performed
        //So no PaymentTermNotFoundException will be thrown here.
        manager.updatePaymentTerm(previousPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new term does not equal to the previous value,
     * but changed status is set as false explicitly, so no updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm6() throws Exception {
        SimpleCommonManager manager = this.getManager();

        PaymentTerm previousPaymentTerm = manager.retrievePaymentTerm(1);
        //"3" does not equal to the previous value of term, but changed status is set as false explicitly
        previousPaymentTerm.setTerm(3);
        previousPaymentTerm.setChanged(false);

        //delete it
        manager.deletePaymentTerm(1);

        //Since the changed status of previousPaymentTerm is false, no updating will be performed
        //So no PaymentTermNotFoundException will be thrown here.
        manager.updatePaymentTerm(previousPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new description does not equal to the previous value, updating will be performed.
     * </p>
     *
     * <p>
     * The modification date is null, it should be ignored.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm7() throws Exception {
        SimpleCommonManager manager = this.getManager();

        PaymentTerm previousPaymentTerm = manager.retrievePaymentTerm(1);
        //"newDesc" does not equal to the previous value of description
        previousPaymentTerm.setDescription("newDesc");
        previousPaymentTerm.setModificationDate(null);

        manager.updatePaymentTerm(previousPaymentTerm);
        assertFalse("Changed status should be false", previousPaymentTerm.isChanged());
        PaymentTerm paymentTermAfterUpdate = manager.retrievePaymentTerm(1);
        assertEquals("The description should be updated to 'newDesc'", "newDesc",
                paymentTermAfterUpdate.getDescription());
        this.assertPaymentTermEquals(previousPaymentTerm, paymentTermAfterUpdate);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new active status does not equal to the previous value, updating will be performed.
     * </p>
     *
     * <p>
     * The modification date exceeds current date, it should be ignored.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm8() throws Exception {
        SimpleCommonManager manager = this.getManager();

        PaymentTerm previousPaymentTerm = manager.retrievePaymentTerm(1);
        //"false" does not equal to the previous value of active, but changed status is set as false explicitly
        previousPaymentTerm.setActive(false);
        previousPaymentTerm.setModificationDate(new Date(new Date().getTime() + ONEDAY));
        manager.updatePaymentTerm(previousPaymentTerm);

        assertFalse("Changed status should be false", previousPaymentTerm.isChanged());
        PaymentTerm paymentTermAfterUpdate = manager.retrievePaymentTerm(1);

        assertFalse("The active status should be updated to false", paymentTermAfterUpdate.isActive());
        this.assertPaymentTermEquals(previousPaymentTerm, paymentTermAfterUpdate);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new term equals to the previous value, updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm9() throws Exception {
        SimpleCommonManager manager = this.getManager();

        PaymentTerm previousPaymentTerm = manager.retrievePaymentTerm(1);
        //"3" does not equal to the previous value of term
        previousPaymentTerm.setTerm(3);

        manager.updatePaymentTerm(previousPaymentTerm);
        assertFalse("Changed status should be false", previousPaymentTerm.isChanged());
        PaymentTerm paymentTermAfterUpdate = manager.retrievePaymentTerm(1);
        assertEquals("The term should be updated to 3", 3, paymentTermAfterUpdate.getTerm());
        this.assertPaymentTermEquals(previousPaymentTerm, paymentTermAfterUpdate);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>retrievePaymentTerm(long)</code>.
     * </p>
     *
     * <p>
     * There are 10 entries previously inserted into payment_terms when this test case set up.
     * Retrieve them one by one. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrievePaymentTerm1() throws Exception {
        SimpleCommonManager manager = this.getManager();
        for (int i = 1; i <= 10; i++) {
            PaymentTerm paymentTerm = manager.retrievePaymentTerm(i);
            this.assertPaymentTerm(paymentTerm, i);
        }
    }

    /**
     * <p>
     * Test accuracy of ctor <code>retrievePaymentTerm(long)</code>.
     * </p>
     *
     * <p>
     * Retrieve <code>PaymentTerm</code> with id from 11 to 20,
     * null should be returned.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrievePaymentTerm2() throws Exception {
        SimpleCommonManager manager = this.getManager();
        for (int i = 11; i <= 20; i++) {
            PaymentTerm paymentTerm = manager.retrievePaymentTerm(i);
            assertNull("The PaymentTerm with id " + i + " should not exist", paymentTerm);
        }
    }

    /**
     * <p>
     * Test accuracy of ctor <code>retrievePaymentTerms(long[])</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into payment_terms when this test case set up.
     * Retrieve all of them. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrievePaymentTerms1() throws Exception {
        SimpleCommonManager manager = this.getManager();
        long[] ids = new long[10];
        for (int i = 1; i <= 10; i++) {
            ids[i - 1] = i;
        }
        PaymentTerm[] paymentTerms = manager.retrievePaymentTerms(ids);
        assertEquals("The length of paymentTerms should be 10", 10, paymentTerms.length);
        for (int i = 1; i <= 10; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], i);
        }
    }

    /**
     *  <p>
     * Test accuracy of ctor <code>retrievePaymentTerms(long[])</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into payment_terms when this test case set up.
     * Retrieve 5 of them. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrievePaymentTerms2() throws Exception {
        SimpleCommonManager manager = this.getManager();
        long[] ids = new long[5];
        for (int i = 1; i <= 5; i++) {
            ids[i - 1] = i;
        }
        PaymentTerm[] paymentTerms = manager.retrievePaymentTerms(ids);
        assertEquals("The length of paymentTerms should be 5", 5, paymentTerms.length);
        for (int i = 1; i <= 5; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], i);
        }
    }

    /**
     *  <p>
     * Test accuracy of ctor <code>retrievePaymentTerms(long[])</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into payment_terms when this test case set up.
     * See data.sql for details.
     * </p>
     *
     * <p>
     * The array of ids contains all ids of these 10 entries, and contains duplicate ids from 1 to 5, and contains
     * ids form 16 to 20 which do not exist in data store. There should be an array of <code>PaymentTerm</code> with
     * length 15 returned.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrievePaymentTerms3() throws Exception {
        SimpleCommonManager manager = this.getManager();
        long[] ids = new long[20];
        for (int i = 1; i <= 20; i++) {
            ids[i - 1] = i;
            if (i >= 11 && i <= 15) {
                ids[i - 1] = i - 10;
            }
        }
        PaymentTerm[] paymentTerms = manager.retrievePaymentTerms(ids);
        assertEquals("The length of paymentTerms should be 15", 15, paymentTerms.length);
        for (int i = 1; i <= 10; i++) {
            int id = i >= 11 ? i - 10 : i;
            this.assertPaymentTerm(paymentTerms[i - 1], id);
        }
    }

    /**
     * <p>
     * Test accuracy of ctor <code>retrievePaymentTerms(long[])</code>.
     * </p>
     *
     * <p>
     * Given an empty ids array to retrieve, an empty array of <code>PaymentTerm</code>s should be returned.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrievePaymentTerms4() throws Exception {
        SimpleCommonManager manager = this.getManager();
        PaymentTerm[] paymentTerms = manager.retrievePaymentTerms(new long[0]);
        assertEquals("The length of paymentTerms should be 0", 0, paymentTerms.length);
    }

    /**
     * <p>
     * Test accuracy of ctor <code>retrieveAllPaymentTerms()</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into payment_terms when this test case set up.
     * Retrieve all of them. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveAllPaymentTerms() throws Exception {
        SimpleCommonManager manager = this.getManager();
        PaymentTerm[] paymentTerms = manager.retrieveAllPaymentTerms();
        assertEquals("The length of paymentTerms should be 10", 10, paymentTerms.length);
        for (int i = 1; i <= 10; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], i);
        }
    }

    /**
     * <p>
     * Test accuracy of ctor <code>retrieveActivePaymentTerms()</code>.
     * </p>
     *
     * <p>
     * There are 5 active <code>PaymentTerm</code>s previously inserted into payment_terms when this test case set up.
     * Retrieve all of them. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveActivePaymentTerms() throws Exception {
        SimpleCommonManager manager = this.getManager();
        PaymentTerm[] paymentTerms = manager.retrieveActivePaymentTerms();
        assertEquals("The length of active paymentTerms should be 5", 5, paymentTerms.length);
        for (int i = 1; i <= 5; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], paymentTerms[i - 1].getId());
        }
    }

    /**
     * <p>
     * Test accuracy for method <code>retrieveRecentlyCreatedPaymentTerms(int)</code>.
     * </p>
     *
     * <p>
     * RecentDays is from 1 to 10, there should be 1 <code>PaymentTerms</code> returned when recentDays is 1,
     * 2 <code>PaymentTerms</code> returned when recentDays is 2......, 10 <code>PaymentTerms</code> returned
     * when recentDays is 10. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveRecentlyCreatedPaymentTerms1() throws Exception {
        SimpleCommonManager manager = this.getManager();
        Thread.sleep(1000);
        for (int recentDays = 1; recentDays <= 10; recentDays++) {
            PaymentTerm[] paymentTerms = manager.retrieveRecentlyCreatedPaymentTerms(recentDays);
            assertEquals("The length of recent created paymentTerms should be " + recentDays,
                   recentDays, paymentTerms.length);
            for (int i = 1; i <= recentDays; i++) {
                this.assertPaymentTerm(paymentTerms[i - 1], paymentTerms[i - 1].getId());
            }
        }
    }

    /**
     * <p>
     * Test accuracy for method <code>retrieveRecentlyCreatedPaymentTerms(int)</code>.
     * </p>
     *
     * <p>
     * RecentDays is <code>Integer.MAX_VALUE</code>, the 10 <code>PaymentTerms</code> previously
     * inserted should be returned. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveRecentlyCreatedPaymentTerms2() throws Exception {
        SimpleCommonManager manager = this.getManager();
        PaymentTerm[] paymentTerms = manager.retrieveRecentlyCreatedPaymentTerms(Integer.MAX_VALUE);
        assertEquals("The length of recent created paymentTerms should be " + 10,
               10, paymentTerms.length);
        for (int i = 1; i <= 10; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], paymentTerms[i - 1].getId());
        }
    }

    /**
     * <p>
     * Test accuracy for method <code>retrieveRecentlyCreatedPaymentTerms()</code>.
     * </p>
     *
     * <p>
     * RecentDays is configured as 3, the first 3 <code>PaymentTerms</code>s previously
     * inserted should be returned. See TimeTrackerCommon.xml and data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveRecentlyCreatedPaymentTerms3() throws Exception {
        SimpleCommonManager manager = this.getManager();
        Thread.sleep(1000);
        PaymentTerm[] paymentTerms = manager.retrieveRecentlyCreatedPaymentTerms();
        assertEquals("The length of recent created paymentTerms should be 3",
               3, paymentTerms.length);
        for (int i = 1; i <= 3; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], paymentTerms[i - 1].getId());
        }
    }
    /**
     * <p>
     * Test accuracy for method <code>retrieveRecentlyModifiedPaymentTerms(int)</code>.
     * </p>
     *
     * <p>
     * RecentDays is from 1 to 10, there should be 1 <code>PaymentTerms</code> returned when recentDays is 1,
     * 2 <code>PaymentTerms</code> returned when recentDays is 2......, 10 <code>PaymentTerms</code> returned
     * when recentDays is 10. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveRecentlyModifiedPaymentTerms1() throws Exception {
        SimpleCommonManager manager = this.getManager();
        Thread.sleep(1000);
        for (int recentDays = 1; recentDays <= 10; recentDays++) {
            PaymentTerm[] paymentTerms = manager.retrieveRecentlyModifiedPaymentTerms(recentDays);
            assertEquals("The length of recent modified paymentTerms should be " + recentDays,
                   recentDays, paymentTerms.length);
            for (int i = 1; i <= recentDays; i++) {
                this.assertPaymentTerm(paymentTerms[i - 1], paymentTerms[i - 1].getId());
            }
        }
    }

    /**
     * <p>
     * Test accuracy for method <code>retrieveRecentlyModifiedPaymentTerms(int)</code>.
     * </p>
     *
     * <p>
     * RecentDays is <code>Integer.MAX_VALUE</code>, the 10 <code>PaymentTerms</code>s previously
     * inserted should be returned. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveRecentlyModifiedPaymentTerms2() throws Exception {
        SimpleCommonManager manager = this.getManager();
        PaymentTerm[] paymentTerms = manager.retrieveRecentlyModifiedPaymentTerms(Integer.MAX_VALUE);
        assertEquals("The length of recent modified paymentTerms should be " + 10,
               10, paymentTerms.length);
        for (int i = 1; i <= 10; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], paymentTerms[i - 1].getId());
        }
    }

    /**
     * <p>
     * Test accuracy for method <code>retrieveRecentlyModifiedPaymentTerms()</code>.
     * </p>
     *
     * <p>
     * RecentDays is configured as 3, the first 3 <code>PaymentTerms</code>s previously
     * inserted should be returned. See TimeTrackerCommon.xml and data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveRecentlyModifiedPaymentTerms3() throws Exception {
        SimpleCommonManager manager = this.getManager();
        Thread.sleep(1000);
        PaymentTerm[] paymentTerms = manager.retrieveRecentlyModifiedPaymentTerms();
        assertEquals("The length of recent modified paymentTerms should be 3",
               3, paymentTerms.length);
        for (int i = 1; i <= 3; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], paymentTerms[i - 1].getId());
        }
    }

    /**
     * <p>
     * Test accuracy for method <code>deletePaymentTerm()</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into data store.
     * Delete them one by one. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testDeletePaymentTerm() throws Exception {
        SimpleCommonManager manager = this.getManager();
        for (int i = 1; i <= 10; i++) {
            manager.deletePaymentTerm(i);
            assertNull("The paymentTerm should be deleted. id = " + i, manager.retrievePaymentTerm(i));
        }
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy for method <code>testDeleteAllPaymentTerms()</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into data store.
     * Delete all of them. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testDeleteAllPaymentTerms() throws Exception {
        SimpleCommonManager manager = this.getManager();
        manager.deleteAllPaymentTerms();
        assertEquals("All the PaymentTerms should be deleted", 0, manager.retrieveAllPaymentTerms().length);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy for method <code>deletePaymentTerms()</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into data store.
     * Delete all of them by passing the ids. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testDeletePaymentTerms1() throws Exception {
        SimpleCommonManager manager = this.getManager();
        long[] ids = new long[10];
        for (int i = 1; i <= 10; i++) {
            ids[i - 1] = i;
        }
        manager.deletePaymentTerms(ids);
        assertEquals("All the PaymentTerms should be deleted", 0, manager.retrieveAllPaymentTerms().length);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy for method <code>deletePaymentTerms()</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into data store.
     * Delete 5 of them by passing the ids. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testDeletePaymentTerms2() throws Exception {
        SimpleCommonManager manager = this.getManager();
        long[] ids = new long[5];
        for (int i = 1; i <= 5; i++) {
            ids[i - 1] = i;
        }
        manager.deletePaymentTerms(ids);
        PaymentTerm[] paymentTerms = manager.retrieveAllPaymentTerms();
        assertEquals("There should 5 PaymentTerms left", 5, paymentTerms.length);
        for (int i = 6; i <= 10; i++) {
            this.assertPaymentTerm(paymentTerms[i - 6], i);
        }
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy for method <code>deletePaymentTerms()</code>.
     * </p>
     *
     * <p>
     * Given an empty ids array to delete, nothing should happen.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testDeletePaymentTerms3() throws Exception {
        SimpleCommonManager manager = this.getManager();
        manager.deletePaymentTerms(new long[0]);
        PaymentTerm[] paymentTerms = manager.retrieveAllPaymentTerms();
        assertEquals("There should also be 10 PaymentTerms existed", 10, paymentTerms.length);
        for (int i = 1; i <= 10; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], i);
        }
    }
}
