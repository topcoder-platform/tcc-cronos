/*
 * Copyright (C) 2007 TopCoder Inc., All Rights Reserved.
 */
package com.topcoder.timetracker.common.persistence;

import com.topcoder.db.connectionfactory.DBConnectionFactoryImpl;
import com.topcoder.timetracker.common.BaseTestCase;
import com.topcoder.timetracker.common.PaymentTerm;
import com.topcoder.util.idgenerator.IDGenerator;


/**
 * <p>This test case contains accuracy tests for <code>DatabasePaymentTermDAO</code>.</p>
 *
 * @author TCSDEVELOPER
 * @version 3.1
 */
public class DatabasePaymentTermDAOTestAcc extends BaseTestCase {
    /**
     * <p>
     * Assert given <code>DatabasePaymentTermDAO(String)</code>.
     * </p>
     *
     * @param dao <code>DatabasePaymentTermDAO(String)</code> to assert.
     *
     * @throws Exception to JUnit
     */
    private void assertDao(DatabasePaymentTermDAO dao) throws Exception {
        assertNotNull(dao);
        assertEquals("The connection should be 'Informix'", "Informix", this.getField(dao, "connectionName"));
        IDGenerator idGenerator = (IDGenerator) this.getField(dao, "idGenerator");
        assertEquals("The name of IDGenerator should be 'PaymentTermGenerator'",
                "PaymentTermGenerator", idGenerator.getIDName());
    }

    /**
     * <p>
     * Test accuracy of ctor <code>DatabasePaymentTermDAO(String)</code>.
     * </p>
     *
     * <p>
     * The connection name should be 'Informix'.
     * The id generator name should be 'PaymentTermGenerator'.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testDatabasePaymentTermDAO_Ctor_WithNamespace() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        assertDao(dao);
    }
    /**
     * <p>
     * Test accuracy of ctor <code>DatabasePaymentTermDAO(String)</code>.
     * </p>
     *
     * <p>
     * The connection name should be 'Informix'.
     * The id generator name should be 'PaymentTermGenerator'.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testDatabasePaymentTermDAO_Ctor_WithOutNamespace() throws Exception {
        DatabasePaymentTermDAO dao = new DatabasePaymentTermDAO(
                new DBConnectionFactoryImpl(DBCONNECTION_FACTORY_NAMESPACE), "Informix", "PaymentTermGenerator");
        assertDao(dao);
    }
    /**
     * <p>
     * Test accuracy of ctor <code>addPaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The <code>PaymentTerm</code> to be added is with id -1(the initial value), it will be ignored and replaced
     * by the id generated by <code>IDGenerator</code>.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testAddPaymentTerm1() throws Exception {
        PaymentTerm paymentTermToBeAdded = this.getPaymentTermWithOutId();
        DatabasePaymentTermDAO dao = this.getDao();
        dao.addPaymentTerm(paymentTermToBeAdded);
        //Note the next_block_start is 11, so 11 is generated here
        assertEquals("The id should be 11", 11, paymentTermToBeAdded.getId());
        assertFalse("Changed status should be false", paymentTermToBeAdded.isChanged());
        PaymentTerm addedPaymentTerm = dao.retrievePaymentTerm(paymentTermToBeAdded.getId());
        this.assertPaymentTermEquals(paymentTermToBeAdded, addedPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>addPaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The <code>PaymentTerm</code> to be added is with id -5, it will be ignored and replaced
     * by the id generated by <code>IDGenerator</code>.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testAddPaymentTerm2() throws Exception {
        PaymentTerm paymentTermToBeAdded = this.getPaymentTermWithOutId();
        paymentTermToBeAdded.setId(-5);
        DatabasePaymentTermDAO dao = this.getDao();
        dao.addPaymentTerm(paymentTermToBeAdded);
        //Note the block_size is 3, so 12 is generated here
        assertEquals("The id should be 12", 12, paymentTermToBeAdded.getId());
        assertFalse("Changed status should be false", paymentTermToBeAdded.isChanged());
        PaymentTerm addedPaymentTerm = dao.retrievePaymentTerm(paymentTermToBeAdded.getId());
        this.assertPaymentTermEquals(paymentTermToBeAdded, addedPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>addPaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The <code>PaymentTerm</code> to be added is with id 5, it will be ignored and replaced
     * by the id generated by <code>IDGenerator</code>.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testAddPaymentTerm3() throws Exception {
        PaymentTerm paymentTermToBeAdded = this.getPaymentTermWithOutId();
        paymentTermToBeAdded.setId(5);
        DatabasePaymentTermDAO dao = this.getDao();
        dao.addPaymentTerm(paymentTermToBeAdded);
        //Note the block_size is 3, so 13 is generated here.
        //But after these 3 times id generation, IDGenerator will query DB again
        //and find that the next_block_start is 11 again
        assertEquals("The id should be 13", 13, paymentTermToBeAdded.getId());
        assertFalse("Changed status should be false", paymentTermToBeAdded.isChanged());
        PaymentTerm addedPaymentTerm = dao.retrievePaymentTerm(paymentTermToBeAdded.getId());
        this.assertPaymentTermEquals(paymentTermToBeAdded, addedPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new description equals to the previous value, so no updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm1() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();

        PaymentTerm previousPaymentTerm = dao.retrievePaymentTerm(1);
        //"desc1" equals to the previous value of description
        previousPaymentTerm.setDescription("desc1");
        previousPaymentTerm.setModificationDate(
            this.getDateWithOneMsForward(previousPaymentTerm.getModificationDate()));

        //delete it
        dao.deletePaymentTerm(1);

        //Since the changed status of previousPaymentTerm is false, no updating will be performed
        //So no PaymentTermNotFoundException will be thrown here.
        dao.updatePaymentTerm(previousPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new active status equals to the previous value, so no updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm2() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();

        PaymentTerm previousPaymentTerm = dao.retrievePaymentTerm(1);
        //"true" equals to the previous value of active
        previousPaymentTerm.setActive(true);
        previousPaymentTerm.setModificationDate(
                this.getDateWithOneMsForward(previousPaymentTerm.getModificationDate()));

        //delete it
        dao.deletePaymentTerm(1);

        //Since the changed status of previousPaymentTerm is false, no updating will be performed
        //So no PaymentTermNotFoundException will be thrown here.
        dao.updatePaymentTerm(previousPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new term equals to the previous value, so no updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm3() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();

        PaymentTerm previousPaymentTerm = dao.retrievePaymentTerm(1);
        //"1" equals to the previous value of term
        previousPaymentTerm.setTerm(1);
        previousPaymentTerm.setModificationDate(
                this.getDateWithOneMsForward(previousPaymentTerm.getModificationDate()));

        //delete it
        dao.deletePaymentTerm(1);

        //Since the changed status of previousPaymentTerm is false, no updating will be performed
        //So no PaymentTermNotFoundException will be thrown here.
        dao.updatePaymentTerm(previousPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new description does not equal to the previous value,
     * but changed status is set as false explicitly, so no updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm4() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();

        PaymentTerm previousPaymentTerm = dao.retrievePaymentTerm(1);
        //"newDesc" does not equal to the previous value of description, but changed status is set as false explicitly
        previousPaymentTerm.setDescription("newDesc");
        previousPaymentTerm.setChanged(false);
        previousPaymentTerm.setModificationDate(
                this.getDateWithOneMsForward(previousPaymentTerm.getModificationDate()));

        //delete it
        dao.deletePaymentTerm(1);

        //Since the changed status of previousPaymentTerm is false, no updating will be performed
        //So no PaymentTermNotFoundException will be thrown here.
        dao.updatePaymentTerm(previousPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new active status does not equal to the previous value,
     * but changed status is set as false explicitly, so no updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm5() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();

        PaymentTerm previousPaymentTerm = dao.retrievePaymentTerm(1);
        //"false" does not equal to the previous value of active, but changed status is set as false explicitly
        previousPaymentTerm.setActive(false);
        previousPaymentTerm.setChanged(false);
        previousPaymentTerm.setModificationDate(
                this.getDateWithOneMsForward(previousPaymentTerm.getModificationDate()));

        //delete it
        dao.deletePaymentTerm(1);

        //Since the changed status of previousPaymentTerm is false, no updating will be performed
        //So no PaymentTermNotFoundException will be thrown here.
        dao.updatePaymentTerm(previousPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new term does not equal to the previous value,
     * but changed status is set as false explicitly, so no updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm6() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();

        PaymentTerm previousPaymentTerm = dao.retrievePaymentTerm(1);
        //"3" does not equal to the previous value of term, but changed status is set as false explicitly
        previousPaymentTerm.setTerm(3);
        previousPaymentTerm.setChanged(false);
        previousPaymentTerm.setModificationDate(
                this.getDateWithOneMsForward(previousPaymentTerm.getModificationDate()));

        //delete it
        dao.deletePaymentTerm(1);

        //Since the changed status of previousPaymentTerm is false, no updating will be performed
        //So no PaymentTermNotFoundException will be thrown here.
        dao.updatePaymentTerm(previousPaymentTerm);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new description does not equal to the previous value, updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm7() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();

        PaymentTerm previousPaymentTerm = dao.retrievePaymentTerm(1);
        //"newDesc" does not equal to the previous value of description
        previousPaymentTerm.setDescription("newDesc");
        previousPaymentTerm.setModificationDate(
                this.getDateWithOneMsForward(previousPaymentTerm.getModificationDate()));

        dao.updatePaymentTerm(previousPaymentTerm);
        assertFalse("Changed status should be false", previousPaymentTerm.isChanged());
        PaymentTerm paymentTermAfterUpdate = dao.retrievePaymentTerm(1);

        this.assertPaymentTermEquals(previousPaymentTerm, paymentTermAfterUpdate);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new active status does not equal to the previous value, updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm8() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();

        PaymentTerm previousPaymentTerm = dao.retrievePaymentTerm(1);
        //"false" does not equal to the previous value of active, but changed status is set as false explicitly
        previousPaymentTerm.setActive(false);
        previousPaymentTerm.setModificationDate(
                this.getDateWithOneMsForward(previousPaymentTerm.getModificationDate()));

        dao.updatePaymentTerm(previousPaymentTerm);
        assertFalse("Changed status should be false", previousPaymentTerm.isChanged());
        PaymentTerm paymentTermAfterUpdate = dao.retrievePaymentTerm(1);
        assertFalse("The active status should be updated to false", paymentTermAfterUpdate.isActive());
        this.assertPaymentTermEquals(previousPaymentTerm, paymentTermAfterUpdate);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>updatePaymentTerm(PaymentTerm)</code>.
     * </p>
     *
     * <p>
     * The new term equals to the previous value, updating will be performed.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testUpdatePaymentTerm9() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();

        PaymentTerm previousPaymentTerm = dao.retrievePaymentTerm(1);
        //"3" does not equal to the previous value of term
        previousPaymentTerm.setTerm(3);
        previousPaymentTerm.setModificationDate(
                this.getDateWithOneMsForward(previousPaymentTerm.getModificationDate()));

        dao.updatePaymentTerm(previousPaymentTerm);
        assertFalse("Changed status should be false", previousPaymentTerm.isChanged());
        PaymentTerm paymentTermAfterUpdate = dao.retrievePaymentTerm(1);
        assertEquals("The term should be updated to 3", 3, paymentTermAfterUpdate.getTerm());
        this.assertPaymentTermEquals(previousPaymentTerm, paymentTermAfterUpdate);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy of ctor <code>retrievePaymentTerm(long)</code>.
     * </p>
     *
     * <p>
     * There are 10 entries previously inserted into payment_terms when this test case set up.
     * Retrieve them one by one. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrievePaymentTerm1() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        for (int i = 1; i <= 10; i++) {
            PaymentTerm paymentTerm = dao.retrievePaymentTerm(i);
            this.assertPaymentTerm(paymentTerm, i);
        }
    }

    /**
     * <p>
     * Test accuracy of ctor <code>retrievePaymentTerm(long)</code>.
     * </p>
     *
     * <p>
     * Retrieve <code>PaymentTerm</code> with id from 11 to 20,
     * null should be returned.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrievePaymentTerm2() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        for (int i = 11; i <= 20; i++) {
            PaymentTerm paymentTerm = dao.retrievePaymentTerm(i);
            assertNull("The PaymentTerm with id " + i + " should not exist", paymentTerm);
        }
    }

    /**
     * <p>
     * Test accuracy of ctor <code>retrievePaymentTerms(long[])</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into payment_terms when this test case set up.
     * Retrieve all of them. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrievePaymentTerms1() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        long[] ids = new long[10];
        for (int i = 1; i <= 10; i++) {
            ids[i - 1] = i;
        }
        PaymentTerm[] paymentTerms = dao.retrievePaymentTerms(ids);
        assertEquals("The length of paymentTerms should be 10", 10, paymentTerms.length);
        for (int i = 1; i <= 10; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], i);
        }
    }

    /**
     *  <p>
     * Test accuracy of ctor <code>retrievePaymentTerms(long[])</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into payment_terms when this test case set up.
     * Retrieve 5 of them. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrievePaymentTerms2() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        long[] ids = new long[5];
        for (int i = 1; i <= 5; i++) {
            ids[i - 1] = i;
        }
        PaymentTerm[] paymentTerms = dao.retrievePaymentTerms(ids);
        assertEquals("The length of paymentTerms should be 5", 5, paymentTerms.length);
        for (int i = 1; i <= 5; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], i);
        }
    }

    /**
     *  <p>
     * Test accuracy of ctor <code>retrievePaymentTerms(long[])</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into payment_terms when this test case set up.
     * See data.sql for details.
     * </p>
     *
     * <p>
     * The array of ids contains all ids of these 10 entries, and contains duplicate ids from 1 to 5, and contains
     * ids form 16 to 20 which do not exist in data store. There should be an array of <code>PaymentTerm</code> with
     * length 15 returned.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrievePaymentTerms3() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        long[] ids = new long[20];
        for (int i = 1; i <= 20; i++) {
            ids[i - 1] = i;
            if (i >= 11 && i <= 15) {
                ids[i - 1] = i - 10;
            }
        }
        PaymentTerm[] paymentTerms = dao.retrievePaymentTerms(ids);
        assertEquals("The length of paymentTerms should be 15", 15, paymentTerms.length);
        for (int i = 1; i <= 10; i++) {
            int id = i >= 11 ? i - 10 : i;
            this.assertPaymentTerm(paymentTerms[i - 1], id);
        }
    }

    /**
     * <p>
     * Test accuracy of ctor <code>retrievePaymentTerms(long[])</code>.
     * </p>
     *
     * <p>
     * Given an empty ids array to retrieve, an empty array of <code>PaymentTerm</code>s should be returned.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrievePaymentTerms4() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        PaymentTerm[] paymentTerms = dao.retrievePaymentTerms(new long[0]);
        assertEquals("The length of paymentTerms should be 0", 0, paymentTerms.length);
    }

    /**
     * <p>
     * Test accuracy of ctor <code>retrieveAllPaymentTerms()</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into payment_terms when this test case set up.
     * Retrieve all of them. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveAllPaymentTerms() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        PaymentTerm[] paymentTerms = dao.retrieveAllPaymentTerms();
        assertEquals("The length of paymentTerms should be 10", 10, paymentTerms.length);
        for (int i = 1; i <= 10; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], i);
        }
    }

    /**
     * <p>
     * Test accuracy of ctor <code>retrieveActivePaymentTerms()</code>.
     * </p>
     *
     * <p>
     * There are 5 active <code>PaymentTerm</code>s previously inserted into payment_terms when this test case set up.
     * Retrieve all of them. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveActivePaymentTerms() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        PaymentTerm[] paymentTerms = dao.retrieveActivePaymentTerms();
        assertEquals("The length of active paymentTerms should be 5", 5, paymentTerms.length);
        for (int i = 1; i <= 5; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], paymentTerms[i - 1].getId());
        }
    }

    /**
     * <p>
     * Test accuracy for method <code>retrieveRecentlyCreatedPaymentTerms()</code>.
     * </p>
     *
     * <p>
     * RecentDays is from 1 to 10, there should be 1 <code>PaymentTerms</code> returned when recentDays is 1,
     * 2 <code>PaymentTerms</code> returned when recentDays is 2......, 10 <code>PaymentTerms</code> returned
     * when recentDays is 10. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveRecentlyCreatedPaymentTerms1() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        Thread.sleep(1000);
        for (int recentDays = 1; recentDays <= 10; recentDays++) {
            PaymentTerm[] paymentTerms = dao.retrieveRecentlyCreatedPaymentTerms(recentDays);
            assertEquals("The length of recent created paymentTerms should be " + recentDays,
                   recentDays, paymentTerms.length);
            for (int i = 1; i <= recentDays; i++) {
                this.assertPaymentTerm(paymentTerms[i - 1], paymentTerms[i - 1].getId());
            }
        }
    }

    /**
     * <p>
     * Test accuracy for method <code>retrieveRecentlyCreatedPaymentTerms()</code>.
     * </p>
     *
     * <p>
     * RecentDays is <code>Integer.MAX_VALUE</code>, the 10 <code>PaymentTerms</code> previously
     * inserted should be returned. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveRecentlyCreatedPaymentTerms2() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        PaymentTerm[] paymentTerms = dao.retrieveRecentlyCreatedPaymentTerms(Integer.MAX_VALUE);
        assertEquals("The length of recent created paymentTerms should be " + 10,
               10, paymentTerms.length);
        for (int i = 1; i <= 10; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], paymentTerms[i - 1].getId());
        }
    }

    /**
     * <p>
     * Test accuracy for method <code>retrieveRecentlyModifiedPaymentTerms()</code>.
     * </p>
     *
     * <p>
     * RecentDays is from 1 to 10, there should be 1 <code>PaymentTerms</code> returned when recentDays is 1,
     * 2 <code>PaymentTerms</code> returned when recentDays is 2......, 10 <code>PaymentTerms</code> returned
     * when recentDays is 10. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveRecentlyModifiedPaymentTerms1() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        Thread.sleep(1000);
        for (int recentDays = 1; recentDays <= 10; recentDays++) {
            PaymentTerm[] paymentTerms = dao.retrieveRecentlyModifiedPaymentTerms(recentDays);
            assertEquals("The length of recent modified paymentTerms should be " + recentDays,
                   recentDays, paymentTerms.length);
            for (int i = 1; i <= recentDays; i++) {
                this.assertPaymentTerm(paymentTerms[i - 1], paymentTerms[i - 1].getId());
            }
        }
    }

    /**
     * <p>
     * Test accuracy for method <code>retrieveRecentlyModifiedPaymentTerms()</code>.
     * </p>
     *
     * <p>
     * RecentDays is <code>Integer.MAX_VALUE</code>, the 10 <code>PaymentTerms</code>s previously
     * inserted should be returned. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testRetrieveRecentlyModifiedPaymentTerms2() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        PaymentTerm[] paymentTerms = dao.retrieveRecentlyModifiedPaymentTerms(Integer.MAX_VALUE);
        assertEquals("The length of recent modified paymentTerms should be " + 10,
               10, paymentTerms.length);
        for (int i = 1; i <= 10; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], paymentTerms[i - 1].getId());
        }
    }

    /**
     * <p>
     * Test accuracy for method <code>deletePaymentTerm()</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into data store.
     * Delete them one by one. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testDeletePaymentTerm() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        for (int i = 1; i <= 10; i++) {
            dao.deletePaymentTerm(i);
            assertNull("The paymentTerm should be deleted. id = " + i, dao.retrievePaymentTerm(i));
        }
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy for method <code>testDeleteAllPaymentTerms()</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into data store.
     * Delete all of them. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testDeleteAllPaymentTerms() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        dao.deleteAllPaymentTerms();
        assertEquals("All the PaymentTerms should be deleted", 0, dao.retrieveAllPaymentTerms().length);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy for method <code>deletePaymentTerms()</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into data store.
     * Delete all of them by passing the ids. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testDeletePaymentTerms1() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        long[] ids = new long[10];
        for (int i = 1; i <= 10; i++) {
            ids[i - 1] = i;
        }
        dao.deletePaymentTerms(ids);
        assertEquals("All the PaymentTerms should be deleted", 0, dao.retrieveAllPaymentTerms().length);
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy for method <code>deletePaymentTerms()</code>.
     * </p>
     *
     * <p>
     * There are 10 <code>PaymentTerm</code>s previously inserted into data store.
     * Delete 5 of them by passing the ids. See data.sql for details.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testDeletePaymentTerms2() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        long[] ids = new long[5];
        for (int i = 1; i <= 5; i++) {
            ids[i - 1] = i;
        }
        dao.deletePaymentTerms(ids);
        PaymentTerm[] paymentTerms = dao.retrieveAllPaymentTerms();
        assertEquals("There should 5 PaymentTerms left", 5, paymentTerms.length);
        for (int i = 6; i <= 10; i++) {
            this.assertPaymentTerm(paymentTerms[i - 6], i);
        }
        this.setupDB();
    }

    /**
     * <p>
     * Test accuracy for method <code>deletePaymentTerms()</code>.
     * </p>
     *
     * <p>
     * Given an empty ids array to delete, nothing should happen.
     * </p>
     *
     * @throws Exception to JUnit
     */
    public void testDeletePaymentTerms3() throws Exception {
        DatabasePaymentTermDAO dao = this.getDao();
        dao.deletePaymentTerms(new long[0]);
        PaymentTerm[] paymentTerms = dao.retrieveAllPaymentTerms();
        assertEquals("There should also be 10 PaymentTerms existed", 10, paymentTerms.length);
        for (int i = 1; i <= 10; i++) {
            this.assertPaymentTerm(paymentTerms[i - 1], i);
        }
    }

}
