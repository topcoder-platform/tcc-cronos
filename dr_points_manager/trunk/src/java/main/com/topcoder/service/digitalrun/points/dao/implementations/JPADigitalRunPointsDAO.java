/*
 * Copyright (C) 2008 TopCoder Inc., All Rights Reserved.
 */
package com.topcoder.service.digitalrun.points.dao.implementations;

import java.util.List;

import javax.persistence.EntityExistsException;
import javax.persistence.EntityManager;

import com.topcoder.search.builder.SearchBuilderException;
import com.topcoder.search.builder.SearchBundle;
import com.topcoder.search.builder.filter.Filter;
import com.topcoder.service.digitalrun.entity.DigitalRunPoints;
import com.topcoder.service.digitalrun.points.DigitalRunPointsDAO;
import com.topcoder.service.digitalrun.points.DigitalRunPointsManagerPersistenceException;
import com.topcoder.service.digitalrun.points.EntityNotFoundException;
import com.topcoder.service.digitalrun.points.Helper;

/**
 * <p>
 * This class implements DigitalRunPointsDAO interface. It also extends the AbstractDAO class. This
 * class manages DigitalRunPoints entities in a JPA persistence (currently the JPA persistence will
 * use Hibernate as a provider but any provider can be used). It uses Search Builder component to
 * search for DigitalRunPoints entities. Each public method performs logging.
 * </p>
 * <p>
 * Thread Safety: This class is not completely thread safe because it doesn't manage transactions
 * and it is also mutable. Anyway, the intent is to use this implementation in a stateless session
 * bean so there will be no thread safety issues generated by this class since the container will
 * ensure thread safety.
 * </p>
 *
 * @author DanLazar, TCSDEVELOPER
 * @version 1.0
 */
public class JPADigitalRunPointsDAO extends AbstractDAO implements DigitalRunPointsDAO {
    /**
     * Present the class name.
     */
    private static final String CLASS_NAME = JPADigitalRunPointsDAO.class.getSimpleName();

    /**
     * The SearchBundle instance that will be used to search for DigitalRunPoints entities instances
     * that match a filter. It has a setter; it cannot be set to null.It will be used in
     * searchDigitalRunPoints method to search for DigitalRunPoints instances that match a given
     * filter.
     */
    private SearchBundle searchBundle;

    /**
     * Default constructor.
     */
    public JPADigitalRunPointsDAO() {
        // Empty
    }

    /**
     * Creates a new digital run points entity into persistence. Returns the DigitalRunPoints
     * instance with id generated.
     *
     * @throws IllegalArgumentException
     *             if argument is null or if its id >0
     * @throws DigitalRunPointsManagerPersistenceException
     *             if any errors occur when accessing the persistent storage
     * @param points
     *            the entity to be created
     * @return entity with id set
     */
    public DigitalRunPoints createDigitalRunPoints(DigitalRunPoints points)
        throws DigitalRunPointsManagerPersistenceException {
        String methodName = CLASS_NAME + ".createDigitalRunPoints()";
        // Log the entrance
        Helper.logEntranceInfo(getLogger(), methodName);

        Helper.checkNullWithLog(points, "points", getLogger(), methodName);
        Helper.checkPositiveWithLog(points.getId(), "points.id", getLogger(), methodName);

        // obtain the EntityManager instance
        EntityManager em = getEntityManager();
        // persist the digital run points entity in the database
        try {
            em.getTransaction().begin();
            em.persist(points);
            em.getTransaction().commit();
        } catch (EntityExistsException e) {
            em.getTransaction().rollback();
            Helper.throwPersitenceExceptionWithLog("EntityExistsException occurs while do persisting.", e,
                    getLogger(), methodName);
        }

        // Log the exit
        Helper.logExitInfo(getLogger(), methodName);
        return points;
    }

    /**
     * Updates the given digital run points entity into persistence.
     *
     * @throws IllegalArgumentException
     *             if argument is null
     * @throws EntityNotFoundException
     *             if a digital run points entity with digital run points entity argument id does
     *             not exist in the persistence
     * @throws DigitalRunPointsManagerPersistenceException
     *             if any errors occur when accessing the persistent storage
     * @param points
     *            the entity to be updated
     */
    public void updateDigitalRunPoints(DigitalRunPoints points) throws EntityNotFoundException,
        DigitalRunPointsManagerPersistenceException {
        String methodName = CLASS_NAME + ".updateDigitalRunPoints()";
        // Log the entrance
        Helper.logEntranceInfo(getLogger(), methodName);

        Helper.checkNullWithLog(points, "points", getLogger(), methodName);

        // obtain the EntityManager instance
        EntityManager em = this.getEntityManager();
        // update the entity
        try {
            em.getTransaction().begin();
            em.merge(points);
            em.getTransaction().commit();
        } catch (IllegalArgumentException iae) {
            em.getTransaction().rollback();
            Helper.throwEntityNotFoundExceptionWithLog("The points is not exist.", iae, getLogger(),
                    methodName);
        }

        // Log the exit
        Helper.logExitInfo(getLogger(), methodName);
    }

    /**
     * Removes the digital run points entity identified by the given id from persistence.
     *
     * @throws IllegalArgumentException
     *             if argument<0
     * @throws EntityNotFoundException
     *             if there is no digital run points entity with the given id in persistence
     * @throws DigitalRunPointsManagerPersistenceException
     *             if any errors occur when accessing the persistent storage
     * @param pointsId
     *            the id that identified the entity to be removed
     */
    public void removeDigitalRunPoints(long pointsId) throws EntityNotFoundException,
        DigitalRunPointsManagerPersistenceException {
        String methodName = CLASS_NAME + ".removeDigitalRunPoints()";
        // Log the entrance
        Helper.logEntranceInfo(getLogger(), methodName + " With Id[" + pointsId + "]");

        Helper.checkNegativeWithLog(pointsId, "pointsId", getLogger(), methodName);

        // obtain the EntityManager instance
        EntityManager em = this.getEntityManager();
        // get the DigitalRunPoints instance to be removed
        DigitalRunPoints points = em.find(DigitalRunPoints.class, new Long(pointsId));
        if (points == null) {
            Helper.throwEntityNotFoundExceptionWithLog("DigitalRunPoints with id[" + pointsId
                    + "] is not exist.", null, getLogger(), methodName);
        }
        // remove the entity
        em.getTransaction().begin();
        em.remove(points);
        em.getTransaction().commit();

        // Log the exit
        Helper.logExitInfo(getLogger(), methodName);
    }

    /**
     * Gets the digital run points entity identified by the given id from persistence.
     *
     * @throws IllegalArgumentException
     *             if argument<0
     * @throws EntityNotFoundException
     *             if there is no digital run points entity with the given id in persistence
     * @throws DigitalRunPointsManagerPersistenceException
     *             if any errors occur when accessing the persistent storage
     * @param pointsId
     *            the id that identifies the entity top be retrieved
     * @return the entity identified by the id
     */
    public DigitalRunPoints getDigitalRunPoints(long pointsId) throws EntityNotFoundException,
        DigitalRunPointsManagerPersistenceException {
        String methodName = CLASS_NAME + ".getDigitalRunPoints()";
        // Log the entrance
        Helper.logEntranceInfo(getLogger(), methodName + " With Id[" + pointsId + "]");

        Helper.checkNegativeWithLog(pointsId, "pointsId", getLogger(), methodName);

        // obtain the EntityManager instance
        EntityManager em = this.getEntityManager();
        // get and return the digital run points entity from the database
        DigitalRunPoints points = em.find(DigitalRunPoints.class, new Long(pointsId));
        if (points == null) {
            Helper.throwEntityNotFoundExceptionWithLog("DigitalRunPoints with id[" + pointsId
                    + "] is not exist.", null, getLogger(), methodName);
        }

        // Log the exit
        Helper.logExitInfo(getLogger(), methodName);
        return points;
    }

    /**
     * Searches the digital run points entities that match the given filter. If there is no digital
     * run points entity that matches the given filter an empty list is returned.
     *
     * @throws IllegalArgumentException
     *             if argument is null
     * @throws IllegalStateException
     *             if searchBundle field is null
     * @throws DigitalRunPointsManagerPersistenceException
     *             if any errors occur when accessing the persistent storage
     * @param filter
     *            the filter used for searching
     * @return the matching digital run points entities
     */
    public List<DigitalRunPoints> searchDigitalRunPoints(Filter filter)
        throws DigitalRunPointsManagerPersistenceException {
        String methodName = CLASS_NAME + ".searchDigitalRunPoints()";
        // Log the entrance
        Helper.logEntranceInfo(getLogger(), methodName);

        Helper.checkNullWithLog(filter, "filter", getLogger(), methodName);
        if (this.searchBundle == null) {
            IllegalStateException ise = new IllegalStateException("The searchBundle is not set.");
            Helper.logException(getLogger(), ise, methodName);
            throw ise;
        }

        // search digital run points entities
        List<DigitalRunPoints> results = null;
        try {
            results = (List<DigitalRunPoints>) searchBundle.search(filter);
        } catch (SearchBuilderException e) {
            Helper.throwPersitenceExceptionWithLog(
                    "SearchBuilderException occurs while searching the result.", e, getLogger(), methodName);
        } catch (ClassCastException e) {
            Helper.throwPersitenceExceptionWithLog("ClassCastException occurs while searching the result.",
                    e, getLogger(), methodName);
        }

        // Log the exit
        Helper.logExitInfo(getLogger(), methodName);
        return results;
    }

    /**
     * Sets the searchBundle field.
     *
     * @throws IllegalArgumentException
     *             if argument is null
     * @param searchBundle
     *            the search bundle
     */
    public void setSearchBundle(SearchBundle searchBundle) {
        Helper.checkNull(searchBundle, "searchBundle");

        this.searchBundle = searchBundle;
    }
}
