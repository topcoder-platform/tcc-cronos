/*
 * Copyright (C) 2008 TopCoder Inc., All Rights Reserved.
 */

package com.topcoder.jira.managers;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.rpc.ServiceException;

import com.atlassian.jira.rpc.exception.RemoteAuthenticationException;
import com.atlassian.jira.rpc.exception.RemoteException;
import com.atlassian.jira.rpc.exception.RemotePermissionException;
import com.atlassian.jira.rpc.exception.RemoteValidationException;
import com.atlassian.jira.rpc.soap.beans.RemotePermissionScheme;
import com.atlassian.jira.rpc.soap.beans.RemoteProject;
import com.atlassian.jira.rpc.soap.beans.RemoteScheme;
import com.atlassian.jira.rpc.soap.beans.RemoteVersion;
import com.topcoder.configuration.ConfigurationAccessException;
import com.topcoder.configuration.ConfigurationObject;
import com.topcoder.configuration.persistence.ConfigurationFileManager;
import com.topcoder.configuration.persistence.ConfigurationPersistenceException;
import com.topcoder.jira.ComponentType;
import com.topcoder.jira.JiraConnectionException;
import com.topcoder.jira.JiraManager;
import com.topcoder.jira.JiraManagerException;
import com.topcoder.jira.JiraNotAuthorizedException;
import com.topcoder.jira.JiraProjectCreationAction;
import com.topcoder.jira.JiraProjectCreationResult;
import com.topcoder.jira.JiraProjectRetrievalResult;
import com.topcoder.jira.JiraProjectRetrievalResultAction;
import com.topcoder.jira.JiraProjectValidationException;
import com.topcoder.jira.JiraSecurityTokenExpiredException;
import com.topcoder.jira.generated.JiraSoapService;
import com.topcoder.jira.generated.JiraSoapServiceServiceLocator;
import com.topcoder.jira.managers.entities.JiraProject;
import com.topcoder.jira.managers.entities.JiraVersion;
import com.topcoder.util.log.Level;
import com.topcoder.util.log.Log;
import com.topcoder.util.log.LogManager;

/**
 * This class provides default implementation of the <code>JiraManager</code> interface. It uses
 * stubs generated by Apache Axis 1.4 to perform remote calls of JIRA SOAP service.
 * <p>
 * Actually each manager method is a wrapper around remote call to the corresponding method of JIRA
 * SOAP service.
 * <p>
 * Connection to JIRA could conceivably be lost at various points during the usage of this
 * component. If this happens, the manager will attempt once to reestablish the connection, and if
 * that fails, a <code>JiraConnectionException</code> will be thrown, and on each subsequent call,
 * an attempt will be made to reestablish the connection.
 * <p>
 * The authorization for users to be able to retrieve information and create pages in specific
 * locations will be handled by JIRA. Before making an API call, the caller is expected to login
 * with a username and password, returning a token. That same token is then passed to the subsequent
 * calls into JIRA. This token is used to verify the user has access to the specific areas being
 * manipulated. If a user attempts an unauthorized call, a <code>JiraNotAuthorizedException</code>
 * is thrown.
 * <p>
 * All the available manager operations performs logging using the Logging Wrapper component.
 * <p>
 * There are two types of logging that can be used:
 * <ol>
 * <li>Standard (non-verbose) logging logs:
 * <ul>
 * <li>Method entry and parameter information (debug level)</li>
 * <li>Any exception (warning level) before rethrown</li>
 * </ul>
 * </li>
 * <li>Detailed (verbose) logging logs:
 * <ul>
 * <li>Entering the method and timestamp (debug level)</li>
 * <li>Method arguments (debug level)</li>
 * <li>Time spent in the method (debug level)</li>
 * <li>Return value (debug level)</li>
 * <li>Any exception before rethrown (warning level)</li>
 * </ul>
 * </li>
 * </ol>
 * <p>
 * Here is the sample usage.
 *
 * <pre>
 * // before usage user can turn on/off logging (null log means that logging is disabled)
 * manager.setLog(LogManager.getLog());
 * // verbose or standard logging can be used
 * manager.setVerboseLogging(true);
 *
 * // at first, user must login (returned security token will be used in other methods)
 * String securityToken = manager.login(UnitTestsgetUserName(), UnitTestsgetPassword());
 *
 * // after login we can create project
 * manager.createProject(securityToken, project, version, ComponentType.APPLICATION);
 *
 * // we can add versions to the project
 * version.setName("otherVersion2");
 * manager.addVersionToProject(securityToken, project, version);
 *
 * // all project versions can be fetched
 * manager.getProjectVersions(securityToken, project.getKey());
 *
 * // version can be released
 * version.setReleased(true);
 * version.setReleaseDate(new Date());
 * manager.releaseVersion(securityToken, project.getKey(), version);
 * // or unreleased
 * version.setReleased(false);
 * manager.releaseVersion(securityToken, project.getKey(), version);
 *
 * // version can be archived
 * manager.archiveVersion(securityToken, project.getKey(), version.getName(), true);
 * // or unarchived
 * manager.archiveVersion(securityToken, project.getKey(), version.getName(), false);
 *
 * // getProject methods are used to retrieve projects (key or id must be specified)
 * manager.getProject(securityToken, project.getKey());
 * manager.getProject(securityToken, Long.valueOf(239));
 * // to retrieve project with specified key and version other method is used
 * manager.getProject(securityToken, project.getKey(), "otherVersion2");
 *
 * // all project versions can also be fetched
 * manager.getProjectVersions(securityToken, project.getKey());
 *
 * // method updateProject is used to update projects
 * project.setDescription("new description");
 * manager.updateProject(securityToken, project);
 *
 * // we can check whether the project with given name exists or not
 * manager.projectExists(securityToken, "some-name");
 *
 * // project can be removed
 * manager.deleteProject(securityToken, project.getKey());
 *
 * // at the end we should logout from system
 * manager.logout(securityToken);
 * </pre>
 *
 * <p>
 * Thread-safety. This class is not thread-safe but application will use the class in a a thread
 * safety fashion and will avoid concurrency issues.
 *
 * @author Mafy, agh
 * @version 1.0
 */

public class DefaultJiraManager implements JiraManager {

    /**
     * Name of the configuration namespace with issue security schemes mapping.
     */
    private static final String ISSUE_SECURITY_SCHEMES_NAMESPACE = "issueSecuritySchemesNamespace";

    /**
     * Name of the configuration namespace with permission schemes mapping.
     */
    private static final String PERMISSION_SCHEMES_NAMESPACE = "permissionSchemesNamespace";

    /**
     * Name of the configuration namespace with notification schemes mapping.
     */
    private static final String NOTIFICATION_SCHEMES_NAMESPACE = "notificationSchemesNamespace";

    /**
     * Name of the configuration namespace with JIRA URL and logger name.
     */
    private static final String JIRA_MANAGER_NAMESPACE = "jiraManagerNamespace";

    /**
     * Key used to retrieve logger name from configuration.
     */
    private static final String LOG_NAME_TOKEN_KEY = "log_name_token";

    /**
     * Key used to retrieve JIRA URL from configuration.
     */
    private static final String JIRA_URL_TOKEN_KEY = "jira_url_token";

    /**
     * Key used to retrieve scheme name associated with generic component from configuration.
     */
    private static final String GENERIC_TOKEN_KEY = "generic_token";

    /**
     * Key used to retrieve scheme name associated with custom component from configuration.
     */
    private static final String CUSTOM_TOKEN_KEY = "custom_token";

    /**
     * Key used to retrieve scheme name associated with application from configuration.
     */
    private static final String APPLICATION_TOKEN_KEY = "application_token";

    /**
     * Map with default mappings of component types to the issue security schemes.
     * <p>
     * Initialized in static constructor.
     */
    private static final Map<ComponentType, String> DEFAULT_ISSUE_SECURITY_MAPPINGS =
        new HashMap<ComponentType, String>();

    /**
     * Map with default mappings of component types to the notification schemes.
     * <p>
     * Initialized in static constructor.
     */
    private static final Map<ComponentType, String> DEFAULT_NOTIFICATION_MAPPINGS =
        new HashMap<ComponentType, String>();

    /**
     * Map with default mappings of component types to the permission schemes.
     * <p>
     * Initialized in static constructor.
     */
    private static final Map<ComponentType, String> DEFAULT_PERMISSION_MAPPINGS =
        new HashMap<ComponentType, String>();

    /**
     * Static constructor used to populate constant mappings.
     */
    static {
        DEFAULT_NOTIFICATION_MAPPINGS.put(ComponentType.APPLICATION, "Client Project Notification Scheme");
        DEFAULT_NOTIFICATION_MAPPINGS.put(ComponentType.CUSTOM_COMPONENT,
            "Component Management Notification Scheme");
        DEFAULT_NOTIFICATION_MAPPINGS.put(ComponentType.GENERIC_COMPONENT,
            "Component Management Notification Scheme");
        DEFAULT_PERMISSION_MAPPINGS.put(ComponentType.APPLICATION, "Client Projects");
        DEFAULT_PERMISSION_MAPPINGS
            .put(ComponentType.CUSTOM_COMPONENT, "Custom Component Permissions Scheme");
        DEFAULT_PERMISSION_MAPPINGS.put(ComponentType.GENERIC_COMPONENT,
            "Generic Component Permission Scheme");
        DEFAULT_ISSUE_SECURITY_MAPPINGS.put(ComponentType.APPLICATION, "Client Project Issues Scheme");
        DEFAULT_ISSUE_SECURITY_MAPPINGS.put(ComponentType.CUSTOM_COMPONENT, "Custom Component Issues Scheme");
        DEFAULT_ISSUE_SECURITY_MAPPINGS.put(ComponentType.GENERIC_COMPONENT,
            "Generic Component Issues Scheme");
    }

    /**
     * This collection maps component type to the issue security scheme's name.
     * <p>
     * This map will be used in <code>createProject</code> method to retrieve issue security
     * scheme for the passed component type from JIRA .
     * <p>
     * Initialized in-place, populated in constructor and never changed afterwards.
     * <p>
     * Will not be null. All available component types will be keys. No other keys will exist.
     * Values will not be null or empty strings.
     */
    private final Map<ComponentType, String> issueSecuritySchemes = new HashMap<ComponentType, String>();

    /**
     * This collection maps component type to the notification scheme's name.
     * <p>
     * This map will be used in <code>createProject</code> method to retrieve notification scheme
     * for the passed component type from JIRA.
     * <p>
     * Initialized in-place, populated in constructor and never changed afterwards.
     * <p>
     * Will not be null. All available component types will be keys. No other keys will exist.
     * Values will not be null or empty strings.
     */
    private final Map<ComponentType, String> notificationSchemes = new HashMap<ComponentType, String>();

    /**
     * This collection maps component type to the permission scheme's name.
     * <p>
     * This map will be used in <code>createProject</code> method to retrieve permission scheme
     * for the passed component type from JIRA .
     * <p>
     * Initialized in-place, populated in constructor and never changed afterwards.
     * <p>
     * Will not be null. All available component types will be keys. No other keys will exist.
     * Values will not be null or empty strings.
     */
    private final Map<ComponentType, String> permissionSchemes = new HashMap<ComponentType, String>();

    /**
     * Object used to interact with JIRA SOAP service. It is used by all methods that interacts with
     * JIRA system.
     * <p>
     * Initialized in constructor to a non-null value.
     * <p>
     * At some point connection to JIRA system could be lost. In this case one more attempt to
     * perform failed operation will be performed.
     */
    private JiraSoapService jiraSoapService;

    /**
     * Object used to retrieve <code>JiraSoapService</code> instance.
     * <p>
     * Initialized in-place and never changed afterwards.
     * <p>
     * Will not be null.
     */
    private final JiraSoapServiceServiceLocator serviceLocator = new JiraSoapServiceServiceLocator();

    /**
     * URL of the JIRA SOAP service.
     * <p>
     * Initialized in constructor and never changed afterwards.
     * <p>
     * Can be null. This means that default URL (taken from service's WSDL) is used.
     * <p>
     * Default value is null.
     */
    private final URL jiraUrl;

    /**
     * Object used to perform logging of all manager operations.
     * <p>
     * Initialized in constructor. Can be accessed/modified via corresponding getter/setter.
     * <p>
     * Can take any value. Null means that logging is disabled.
     */
    private Log log = null;

    /**
     * Flag that indicates whether the detailed logging (true value) or standard logging (false
     * value) is used.
     * <p>
     * Initialized in-place to false. Can be accessed/modified via corresponding getter/setter.
     */
    private boolean verboseLogging = false;

    /**
     * Creates a new <code>DefaultJiraManager</code> instance.
     * <p>
     * Fields are initialized to default values:
     * <ol>
     * <li>URL taken from service's WSDL will be used as service's URL.</li>
     * <li>The following mapping of component types to notification schemes' names will be used:
     * <ul>
     * <li>Generic - "Component Management Notification Scheme"</li>
     * <li>Custom - "Component Management Notification Scheme"</li>
     * <li>Application - "Client Project Notification Scheme"</li>
     * </ul>
     * </li>
     * <li>The following mapping of component types to permission schemes' names will be used:
     * <ul>
     * <li>Generic - "Generic Component Permission Scheme"</li>
     * <li>Custom - "Custom Component Permissions Scheme"</li>
     * <li>Application - "Client Projects"</li>
     * </ul>
     * </li>
     * <li>The following mapping of component types to issue security schemes' names will be used:
     * <ul>
     * <li>Generic - "Generic Component Issues Scheme"</li>
     * <li>Custom - "Custom Component Issues Scheme"</li>
     * <li>Application - "Client Project Issues Scheme"</li>
     * </ul>
     * </li>
     * <li>Default console logger retrieved from the Logging Wrapper component will be used.</li>
     * <li>Verbose logging will be turned off (standard logging is used).</li>
     * </ol>
     *
     * @throws JiraManagerException if service couldn't be retrieved from service locator.
     */
    public DefaultJiraManager() throws JiraManagerException {
        // set URL to null
        jiraUrl = null;
        // get default console logger (underlying method doesn't throw
        // exceptions)
        // verbose flag will be set to false by default
        log = LogManager.getLog();

        // populate maps with default values
        notificationSchemes.putAll(DEFAULT_NOTIFICATION_MAPPINGS);
        permissionSchemes.putAll(DEFAULT_PERMISSION_MAPPINGS);
        issueSecuritySchemes.putAll(DEFAULT_ISSUE_SECURITY_MAPPINGS);

        // get service
        updateServiceField();
    }

    /**
     * Creates a new <code>DefaultJiraManager</code> instance with arguments taken from the
     * configuration. Description of configuration follows.
     * <p>
     * Required namespace 'jiraManagerNamespace':
     * <ul>
     * <li>'Log_name_token' - configuration log name. Optional string. Can be null or empty.</li>
     * <li>'jira_url_token' - URL of the JIRA SOAP service. Optional string. If presents must be
     * valid URL.</li>
     * </ul>
     * <p>
     * Optional namespace 'notificationSchemesNamespace' (if namespace is missed then default
     * mapping of notification schemes is used):
     * <ul>
     * <li>'Generic_token' - name of notification scheme used for generic components. Required
     * string. Can not be null or empty.</li>
     * <li>'Custom_token' - name of notification scheme used for custom components. Required
     * string. Can not be null or empty.</li>
     * <li>'Application_token' - name of notification scheme used for applications. Required
     * string. Can not be null or empty.</li>
     * </ul>
     * <p>
     * Optional namespace 'permissionSchemesNamespace' (if namespace is missed then default mapping
     * of permission schemes is used):
     * <ul>
     * <li>'Generic_token' - name of permission scheme used for generic components. Required
     * string. Can not be null or empty.</li>
     * <li>'Custom_token' - name of permission scheme used for custom components. Required string.
     * Can not be null or empty.</li>
     * <li>'Application_token' - name of permission scheme used for applications. Required string.
     * Can not be null or empty.</li>
     * </ul>
     * <p>
     * Optional namespace 'issueSecuritySchemesNamespace' (if namespace is missed then default
     * mapping of issue security schemes is used):
     * <ul>
     * <li>'Generic_token' - name of issue security scheme used for generic components. Required
     * string. Can not be null or empty.</li>
     * <li>'Custom_token' - name of issue security scheme used for custom components. Required
     * string. Can not be null or empty.</li>
     * <li>'Application_token' - name of issue security scheme used for applications. Required
     * string. Can not be null or empty.</li>
     * </ul>
     *
     * @param configurationObject configuration to use
     * @throws IllegalArgumentException if argument is null.
     * @throws JiraManagerConfigurationException if configuration data are invalid.
     * @throws JiraManagerException if service couldn't be retrieved from service locator.
     */
    public DefaultJiraManager(ConfigurationObject configurationObject) throws JiraManagerException {
        checkNotNull(configurationObject, "configurationObject");

        // get URL and log
        URL url = null;
        ConfigurationObject common = retrieveChild(configurationObject, JIRA_MANAGER_NAMESPACE);
        if (common != null) {
            // if configuration namespace exists the retrieve values (both can
            // be null)
            String temp = retrievePropertyValue(common, JIRA_URL_TOKEN_KEY, true);
            if (temp != null) {
                try {
                    url = new URL(temp);
                } catch (MalformedURLException e) {
                    throw new JiraManagerConfigurationException("JIRA URL is malformed.", e);
                }
            }

            String logName = retrievePropertyValue(common, LOG_NAME_TOKEN_KEY, true);
            if (logName != null) {
                this.log = LogManager.getLog(logName);
            }
        }
        this.jiraUrl = url;

        // read mappings
        readMapping(configurationObject, notificationSchemes, NOTIFICATION_SCHEMES_NAMESPACE,
            DEFAULT_NOTIFICATION_MAPPINGS);
        readMapping(configurationObject, permissionSchemes, PERMISSION_SCHEMES_NAMESPACE,
            DEFAULT_PERMISSION_MAPPINGS);
        readMapping(configurationObject, issueSecuritySchemes, ISSUE_SECURITY_SCHEMES_NAMESPACE,
            DEFAULT_ISSUE_SECURITY_MAPPINGS);

        // get service
        updateServiceField();
    }

    /**
     * Creates a new <code>DefaultJiraManager</code> instance with the given arguments.
     * <p>
     * Verbose logging will be turned off (standard logging is used).
     *
     * @param jiraUrl URL of the JIRA SOAP service. Can be null. If presents must be valid URL.
     * @param log object used to perform logging of all manager operations. Can take any value. Null
     *        means that logging is disabled.
     * @param notificationSchemes collection that maps component types to the notification scheme's
     *        name. Null means that default mapping will be used.
     * @param permissionSchemes collection that maps component types to the permission scheme's
     *        name. Null means that default mapping will be used.
     * @param issueSecuritySchemes collection that maps component types to the issue security
     *        scheme's name. Null means that default mapping will be used.
     * @throws IllegalArgumentException if URL is malformed; if one of the maps is invalid. Map is
     *         valid if all available component types are keys of the map and no other keys exist.
     *         The other condition is that all map values must not be null or empty strings.
     * @throws JiraManagerException if service couldn't be retrieved from service locator.
     */
    public DefaultJiraManager(String jiraUrl, Log log, Map<ComponentType, String> notificationSchemes,
        Map<ComponentType, String> permissionSchemes, Map<ComponentType, String> issueSecuritySchemes)
        throws JiraManagerException {
        // check maps
        checkMap(notificationSchemes, "notificationSchemes");
        checkMap(permissionSchemes, "permissionSchemes");
        checkMap(issueSecuritySchemes, "issueSecuritySchemes");
        // check URL
        URL url = null;
        try {
            url = new URL(jiraUrl);
        } catch (MalformedURLException e) {
            throw new IllegalArgumentException("Provided URL is malformed.", e);
        }

        // update maps
        this.notificationSchemes.putAll(notificationSchemes == null ? DEFAULT_NOTIFICATION_MAPPINGS
            : notificationSchemes);
        this.permissionSchemes.putAll(permissionSchemes == null ? DEFAULT_PERMISSION_MAPPINGS
            : permissionSchemes);
        this.issueSecuritySchemes.putAll(issueSecuritySchemes == null ? DEFAULT_ISSUE_SECURITY_MAPPINGS
            : issueSecuritySchemes);

        // update log
        this.log = log;
        // update URL
        this.jiraUrl = url;

        // get service
        updateServiceField();
    }

    /**
     * Creates a new <code>DefaultJiraManager</code> instance using configuration data specified
     * with the given file.
     *
     * @param filename name of the configuration file. Can not be null or empty string.
     * @param namespace namespace. Can not be null or empty string.
     * @throws IllegalArgumentException if one of the arguments is null or empty.
     * @throws JiraManagerConfigurationException if configuration data are invalid.
     * @throws JiraManagerException if service couldn't be retrieved from service locator.
     */
    public DefaultJiraManager(String filename, String namespace) throws JiraManagerException {
        this(getConfigurationObject(filename, namespace));
    }

    /**
     * Adds version to the JIRA project.
     * <p>
     * If version with the same name (case-insensitive check is used) exists then nothing happens.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>. Can not
     *        be null or empty string.
     * @param project project where version should be added. Can not be null.
     * @param version attributes of the version to add. Can not be null.
     * @return non-null JIRA project creation result.
     * @throws IllegalArgumentException if one of the arguments is null or authentication token is
     *         empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation (for example
     *         project doesn't exist).
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    public JiraProjectCreationResult addVersionToProject(String token, JiraProject project,
        JiraVersion version) throws JiraManagerException {
        checkString(token, "token");
        checkNotNull(project, "project");
        checkNotNull(version, "version");

        JiraProjectCreationResult result = null;

        long start = logEntry("addVersionToProject", "token", token, "project", project, "version", version);
        try {
            // get project key
            String projectKey = project.getKey();
            // update local project with existing (id was retrieved)
            project = convertToLocalProject(getExistingRemoteProjectByKey(token, projectKey));

            // get version (if exists)
            RemoteVersion remoteVersion = getRemoteVersionByName(token, projectKey, version.getName());
            boolean versionExists = true;
            if (remoteVersion == null) {
                versionExists = false;
                // create version
                remoteVersion = addRemoteVersion(token, projectKey, convertToRemoteVersion(version));
            }
            // update local version (id was retrieved)
            version = convertToLocalVersion(remoteVersion);

            // create creation result
            JiraProjectCreationAction action =
                versionExists ? JiraProjectCreationAction.PROJECT_AND_VERSION_EXISTED
                    : JiraProjectCreationAction.PROJECT_EXISTED_VERSION_CREATED;
            result = new JiraProjectCreationResult(project, version, action);
        } catch (JiraManagerException e) {
            logError("addVersionToProject", e);
            throw e;
        }

        logExit("addVersionToProject", start, result);
        return result;
    }

    /**
     * Retrieves existing project with the given key from JIRA system.
     * <p>
     * If project doesn't exist then exception will be thrown.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param projectKey key to search project for
     * @return retrieved project.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation (for example
     *         project doesn't exist).
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteProject getExistingRemoteProjectByKey(String token, String projectKey)
        throws JiraManagerException {
        try {
            return getExistingRemoteProjectByKeyRoutine(token, projectKey);
        } catch (java.rmi.RemoteException e) {
            // retry
            try {
                return getExistingRemoteProjectByKeyRoutine(token, projectKey);
            } catch (java.rmi.RemoteException ex) {
                throw new JiraConnectionException("Unable to establish connection.", ex);
            }
        }
    }

    /**
     * Retrieves existing project with the given key from JIRA system.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param projectKey key to search project for
     * @return retrieved project.
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation (for example
     *         project doesn't exist).
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteProject getExistingRemoteProjectByKeyRoutine(String token, String projectKey)
        throws java.rmi.RemoteException, JiraManagerException {
        RemoteProject result;
        try {
            result = jiraSoapService.getProjectByKey(token, projectKey);
        } catch (RemotePermissionException e) {
            throw new JiraNotAuthorizedException("User doesn't have permissions to get project.", e);
        } catch (RemoteAuthenticationException e) {
            throw new JiraSecurityTokenExpiredException("Authentication token is invalid.", e);
        } catch (RemoteException e) {
            throw new JiraManagerException("Unable to retrieve project by key.", e);
        }

        return result;
    }

    /**
     * Adds version to the JIRA project.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param projectKey key of the project
     * @param remoteVersion version to add
     * @return added version
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation (for example
     *         project doesn't exist).
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteVersion addRemoteVersion(String token, String projectKey, RemoteVersion remoteVersion)
        throws JiraManagerException {
        try {
            return addVersionToProjectRoutine(token, projectKey, remoteVersion);
        } catch (java.rmi.RemoteException e) {
            try {
                return addVersionToProjectRoutine(token, projectKey, remoteVersion);
            } catch (java.rmi.RemoteException ex) {
                throw new JiraConnectionException("Unable to establish connection.", ex);
            }
        }
    }

    /**
     * Adds version to the JIRA project.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param projectKey key of the project
     * @param version version to add
     * @return added version
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation (for example
     *         project doesn't exist).
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteVersion addVersionToProjectRoutine(String token, String projectKey, RemoteVersion version)
        throws java.rmi.RemoteException, JiraManagerException {
        try {
            return jiraSoapService.addVersion(token, projectKey, version);
        } catch (RemoteException e) {
            // method addVersion throws only RemoteException so we need to parse fault string
            throw parseRemoteException(e);
        }
    }

    /**
     * Retrieves version by the given name (case-insensitive check is used here).
     *
     * @param token token SOAP authentication token. It's created by method <code>login</code>.
     * @param projectKey key of the project to get version from
     * @param versionName name of the version
     * @return retrieved version or null if version with the given name was not found.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteVersion getRemoteVersionByName(String token, String projectKey, String versionName)
        throws JiraManagerException {
        RemoteVersion[] existingVersions = getRemoteVersionsForProject(token, projectKey);
        for (RemoteVersion existingVersion : existingVersions) {
            if (existingVersion.getName().equalsIgnoreCase(versionName)) {
                // version exists
                return existingVersion;
            }
        }

        return null;
    }

    /**
     * Retrieves all versions of the given project.
     * <p>
     * Returns array of <code>RemoteVersion</code> instances.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param projectKey key of the project to retrieve versions for
     * @return non-null array of project versions.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteVersion[] getRemoteVersionsForProject(String token, String projectKey)
        throws JiraManagerException {
        RemoteVersion[] versions;
        try {
            versions = getRemoteVersionsForProjectRoutine(token, projectKey);
        } catch (java.rmi.RemoteException e) {
            try {
                versions = getRemoteVersionsForProjectRoutine(token, projectKey);
            } catch (java.rmi.RemoteException ex) {
                throw new JiraConnectionException("Unable to establish connection.", ex);
            }
        }
        return versions;
    }

    /**
     * Retrieves versions of project with the given name.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token security token
     * @param projectKey key of the project to get versions from
     * @return retrieved versions or null if project doesn't exist.
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteVersion[] getRemoteVersionsForProjectRoutine(String token, String projectKey)
        throws java.rmi.RemoteException, JiraManagerException {
        try {
            return jiraSoapService.getVersions(token, projectKey);
        } catch (RemotePermissionException e) {
            throw new JiraNotAuthorizedException("User doesn't have permissions to get versions.", e);
        } catch (RemoteAuthenticationException e) {
            throw new JiraSecurityTokenExpiredException("Authentication token is invalid.", e);
        } catch (RemoteException e) {
            throw new JiraManagerException("Unable to retrieve project versions.", e);
        }
    }

    /**
     * Archives or unarchives specified version of the JIRA project.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>. Can not
     *        be null or empty string.
     * @param projectKey key of the project to process. Can not be null or empty string.
     * @param versionName name of the version to process. Can not be null or empty string.
     * @param archive flag that indicates whether the version will be archived or unarchived. True
     *        means that version will be archived and false that version will be unarchived.
     * @throws IllegalArgumentException if one of the arguments is null or empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    public void archiveVersion(String token, String projectKey, String versionName, boolean archive)
        throws JiraManagerException {
        checkString(token, "token");
        checkString(projectKey, "projectKey");
        checkString(versionName, "versionName");

        long start =
            logEntry("archiveVersion", "token", token, "projectKey", projectKey, "versionName", versionName,
                "archive", archive);

        try {
            // archive version
            try {
                archiveVersionRoutine(token, projectKey, versionName, archive);
            } catch (java.rmi.RemoteException e) {
                try {
                    archiveVersionRoutine(token, projectKey, versionName, archive);
                } catch (java.rmi.RemoteException ex) {
                    throw new JiraConnectionException("Unable to establish connection.", ex);
                }
            }
        } catch (JiraManagerException e) {
            logError("archiveVersion", e);
            throw e;
        }
        logExit("archiveVersion", start, "void");
    }

    /**
     * Archives or unarchives specified version of the JIRA project.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param projectKey key of the project to process.
     * @param versionName name of the version to process.
     * @param archive flag that indicates whether the version will be archived or unarchived. True
     *        means that version will be archived and false that version will be unarchived.
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation (for example
     *         project doesn't exist).
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private void archiveVersionRoutine(String token, String projectKey, String versionName, boolean archive)
        throws java.rmi.RemoteException, JiraManagerException {
        try {
            jiraSoapService.archiveVersion(token, projectKey, versionName, archive);
        } catch (RemoteException e) {
            // method archiveVersion throws only RemoteException so we need to parse fault string
            throw parseRemoteException(e);
        }
    }

    /**
     * Creates new JIRA project using the given authentication token, project, version and type.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>. Can not
     *        be null or empty string.
     * @param project attributes of the project to create. Can not be null.
     * @param version attributes of the version to add. Can not be null.
     * @param type type used to retrieve permission, notification and issue security schemes. Can
     *        not be null.
     * @return non-null JIRA project creation result.
     * @throws IllegalArgumentException if one of the arguments is null or authentication token is
     *         empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraProjectValidationException if project is incomplete or malformed.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    public JiraProjectCreationResult createProject(String token, JiraProject project, JiraVersion version,
        ComponentType type) throws JiraManagerException {
        checkString(token, "token");
        checkNotNull(project, "project");
        checkNotNull(version, "version");
        checkNotNull(type, "type");

        JiraProjectCreationResult result = null;

        long start =
            logEntry("createProject", "token", token, "project", project, "version", version, "type", type);
        try {
            // project key
            String projectKey = project.getKey();

            // check whether the project exists
            RemoteProject existingProject = getRemoteProjectByKey(token, projectKey);
            boolean projectExists = existingProject != null;

            // get project to pass to the remote service
            RemoteProject remoteProject = convertToRemoteProject(project);
            // update id if project already exists
            if (projectExists) {
                remoteProject.setId(existingProject.getId());
            }

            // set notification scheme
            try {
                remoteProject.setNotificationScheme(getSchemeByName(notificationSchemes.get(type),
                    getNotificationSchemesRoutine(token)));
            } catch (java.rmi.RemoteException ex) {
                try {
                    remoteProject.setNotificationScheme(getSchemeByName(notificationSchemes.get(type),
                        getNotificationSchemesRoutine(token)));
                } catch (java.rmi.RemoteException e) {
                    throw new JiraConnectionException("Unable to establish connection.", ex);
                }
            }

            // set permission scheme
            try {
                remoteProject.setPermissionScheme(getSchemeByName(permissionSchemes.get(type),
                    getPermissionSchemesRoutine(token)));
            } catch (java.rmi.RemoteException ex) {
                try {
                    remoteProject.setPermissionScheme(getSchemeByName(permissionSchemes.get(type),
                        getPermissionSchemesRoutine(token)));
                } catch (java.rmi.RemoteException e) {
                    throw new JiraConnectionException("Unable to establish connection.", ex);
                }
            }

            // set issue security scheme
            // only Enterprise edition supports issue security schemes
            try {
                remoteProject.setIssueSecurityScheme(getSchemeByName(issueSecuritySchemes.get(type),
                    getIssueSecuritySchemesRoutine(token)));
            } catch (java.rmi.RemoteException ex) {
                try {
                    remoteProject.setIssueSecurityScheme(getSchemeByName(issueSecuritySchemes.get(type),
                        getIssueSecuritySchemesRoutine(token)));
                } catch (java.rmi.RemoteException e) {
                    throw new JiraConnectionException("Unable to establish connection.", ex);
                }
            }

            // we have to create new project or update existing one
            if (projectExists) {
                remoteProject = updateRemoteProject(token, remoteProject);
            } else {
                // create new project
                try {
                    remoteProject = createProjectRoutine(token, remoteProject);
                } catch (java.rmi.RemoteException e) {
                    try {
                        remoteProject = createProjectRoutine(token, remoteProject);
                    } catch (java.rmi.RemoteException ex) {
                        throw new JiraConnectionException("Unable to establish connection.", ex);
                    }
                }
            }
            // convert result of creation
            project = convertToLocalProject(remoteProject);

            // check whether version exists or not
            RemoteVersion remoteVersion = getRemoteVersionByName(token, projectKey, version.getName());
            boolean versionExists = true;
            if (remoteVersion == null) {
                versionExists = false;
                // create version
                remoteVersion = addRemoteVersion(token, projectKey, convertToRemoteVersion(version));
            }
            // update local version (id was retrieved)
            version = convertToLocalVersion(remoteVersion);

            // create creation result
            JiraProjectCreationAction action;
            if (projectExists) {
                action =
                    versionExists ? JiraProjectCreationAction.PROJECT_AND_VERSION_EXISTED
                        : JiraProjectCreationAction.PROJECT_EXISTED_VERSION_CREATED;
            } else {
                action = JiraProjectCreationAction.PROJECT_AND_VERSION_CREATED;
            }
            result = new JiraProjectCreationResult(project, version, action);
        } catch (JiraManagerException e) {
            logError("createProject", e);
            throw e;
        }

        logExit("createProject", start, result);
        return result;
    }

    /**
     * Retrieves project with the given key from JIRA system. The difference from
     * <code>getExistingRemoteProjectByKey</code> is that this method returns null if project with
     * the given key doesn't exist.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param projectKey key to search project for
     * @return retrieved project or null if project doesn't exist.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteProject getRemoteProjectByKey(String token, String projectKey) throws JiraManagerException {
        // get all available projects
        RemoteProject[] projects = getRemoteProjects(token);
        // search
        for (RemoteProject remoteProject : projects) {
            if (remoteProject.getKey().equalsIgnoreCase(projectKey)) {
                return remoteProject;
            }
        }
        return null;
    }

    /**
     * Retrieves all available remote projects.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token security token
     * @return retrieved projects.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteProject[] getRemoteProjects(String token) throws JiraManagerException {
        try {
            return getRemoteProjectsRoutine(token);
        } catch (java.rmi.RemoteException e) {
            try {
                return getRemoteProjectsRoutine(token);
            } catch (java.rmi.RemoteException ex) {
                throw new JiraConnectionException("Unable to establish connection.", ex);
            }
        }
    }

    /**
     * Retrieves all available remote projects.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @return retrieved projects.
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteProject[] getRemoteProjectsRoutine(String token) throws java.rmi.RemoteException,
        JiraManagerException {
        try {
            return jiraSoapService.getProjectsNoSchemes(token);
        } catch (RemotePermissionException e) {
            throw new JiraNotAuthorizedException("User doesn't have permissions to list projects.", e);
        } catch (RemoteAuthenticationException e) {
            throw new JiraSecurityTokenExpiredException("Authentication token is invalid.", e);
        } catch (RemoteException e) {
            throw new JiraManagerException("List of available projects couldn't be retrieved.", e);
        }
    }

    /**
     * Retrieves issue security schemes from JIRA system.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @return array of issue security schemes or null if schemes don't exist
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteScheme[] getIssueSecuritySchemesRoutine(String token) throws java.rmi.RemoteException,
        JiraManagerException {
        try {
            return jiraSoapService.getSecuritySchemes(token);
        } catch (RemotePermissionException e) {
            throw new JiraNotAuthorizedException("User doesn't have permissions to get schemes.", e);
        } catch (RemoteAuthenticationException e) {
            throw new JiraSecurityTokenExpiredException("Authentication token is invalid.", e);
        } catch (RemoteException e) {
            // some JIRA editions don't support issue security schemes
            return null;
        }
    }

    /**
     * Retrieves notification schemes from JIRA system.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @return array of notification schemes or null if schemes don't exist
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteScheme[] getNotificationSchemesRoutine(String token) throws java.rmi.RemoteException,
        JiraManagerException {
        try {
            return jiraSoapService.getNotificationSchemes(token);
        } catch (RemotePermissionException e) {
            throw new JiraNotAuthorizedException("User doesn't have permissions to get schemes.", e);
        } catch (RemoteAuthenticationException e) {
            throw new JiraSecurityTokenExpiredException("Authentication token is invalid.", e);
        } catch (RemoteException e) {
            throw new JiraManagerException("Unable to get notification schemes.", e);
        }
    }

    /**
     * Retrieves permission schemes from JIRA system.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @return array of permission schemes or null if schemes don't exist
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemotePermissionScheme[] getPermissionSchemesRoutine(String token)
        throws java.rmi.RemoteException, JiraManagerException {
        try {
            return jiraSoapService.getPermissionSchemes(token);
        } catch (RemotePermissionException e) {
            throw new JiraNotAuthorizedException("User doesn't have permissions to get schemes.", e);
        } catch (RemoteAuthenticationException e) {
            throw new JiraSecurityTokenExpiredException("Authentication token is invalid.", e);
        } catch (RemoteException e) {
            throw new JiraManagerException("Unable to get permission schemes.", e);
        }
    }

    /**
     * Searches for the scheme with the given name (case-insensitive).
     *
     * @param <T> type of the remote scheme
     * @param schemeName name to search for
     * @param schemes array of schemes to search in
     * @return scheme with the given name or null if scheme is not found.
     */
    private <T extends RemoteScheme> T getSchemeByName(String schemeName, T[] schemes) {
        if (schemes == null) {
            return null;
        }
        for (T scheme : schemes) {
            if (scheme.getName().equalsIgnoreCase(schemeName)) {
                return scheme;
            }
        }
        return null;
    }

    /**
     * Creates project in JIRA system.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param project entity with properties used to create JIRA project
     * @return non-null entity with created properties of the JIRA project.
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraProjectValidationException if project is incomplete or malformed.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteProject createProjectRoutine(String token, RemoteProject project)
        throws java.rmi.RemoteException, JiraManagerException {
        try {
            return jiraSoapService.createProjectFromObject(token, project);
        } catch (RemotePermissionException e) {
            throw new JiraNotAuthorizedException("User doesn't have permissions to create project.", e);
        } catch (RemoteAuthenticationException e) {
            throw new JiraSecurityTokenExpiredException("Authentication token is invalid.", e);
        } catch (RemoteValidationException e) {
            throw new JiraProjectValidationException("Project properties are incomplete or malformed.", e);
        } catch (RemoteException e) {
            throw new JiraManagerException("Unable to create project.", e);
        }
    }

    /**
     * Updates project in JIRA system.
     * <p>
     * This method assumes that passed project contains all required information (include schemes).
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param remoteProject entity with properties used to update JIRA project
     * @return entity with updated properties of the JIRA project.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraProjectValidationException if project is incomplete or malformed.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteProject updateRemoteProject(String token, RemoteProject remoteProject)
        throws JiraManagerException {
        // perform update
        try {
            return updateProjectRoutine(token, remoteProject);
        } catch (java.rmi.RemoteException e) {
            try {
                return updateProjectRoutine(token, remoteProject);
            } catch (java.rmi.RemoteException ex) {
                throw new JiraConnectionException("Unable to establish connection.", ex);
            }
        }
    }

    /**
     * Updates project in JIRA system.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param project entity with properties used to update JIRA project
     * @return entity with updated properties of the JIRA project.
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraProjectValidationException if project is incomplete or malformed.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteProject updateProjectRoutine(String token, RemoteProject project)
        throws java.rmi.RemoteException, JiraManagerException {
        try {
            return jiraSoapService.updateProject(token, project);
        } catch (RemotePermissionException e) {
            throw new JiraNotAuthorizedException("User doesn't have permissions to update project.", e);
        } catch (RemoteAuthenticationException e) {
            throw new JiraSecurityTokenExpiredException("Authentication token is invalid.", e);
        } catch (RemoteValidationException e) {
            throw new JiraProjectValidationException("Project properties are incomplete or malformed.", e);
        } catch (RemoteException e) {
            throw new JiraManagerException("Unable to update project.", e);
        }
    }

    /**
     * Removes project with the given key.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>. Can not
     *        be null or empty string.
     * @param projectKey key of the project to remove. Can not be null or empty string.
     * @throws IllegalArgumentException if one of the arguments is null or empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation (for example
     *         project doesn't exist).
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    public void deleteProject(String token, String projectKey) throws JiraManagerException {
        checkString(token, "token");
        checkString(projectKey, "projectKey");

        long start = logEntry("deleteProject", "token", token, "projectKey", projectKey);
        try {
            try {
                deleteProjectRoutine(token, projectKey);
            } catch (java.rmi.RemoteException e) {
                try {
                    deleteProjectRoutine(token, projectKey);
                } catch (java.rmi.RemoteException ex) {
                    throw new JiraConnectionException("Unable to establish connection.", ex);
                }
            }
        } catch (JiraManagerException e) {
            logError("deleteProject", e);
            throw e;
        }
        logExit("deleteProject", start, "void");
    }

    /**
     * Removes project with the given key.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param projectKey key of the project to remove.
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation (for example
     *         project doesn't exist).
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private void deleteProjectRoutine(String token, String projectKey) throws java.rmi.RemoteException,
        JiraManagerException {
        try {
            jiraSoapService.deleteProject(token, projectKey);
        } catch (RemotePermissionException e) {
            throw new JiraNotAuthorizedException("User doesn't have permissions to delete project.", e);
        } catch (RemoteAuthenticationException e) {
            throw new JiraSecurityTokenExpiredException("Authentication token is invalid.", e);
        } catch (RemoteException e) {
            throw new JiraManagerException("Unable to delete project.", e);
        }
    }

    /**
     * Returns object used to perform logging of all manager operations.
     * <p>
     * Null means that logging is disabled.
     *
     * @return object used to perform logging of all manager operations.
     */
    public Log getLog() {
        return log;
    }

    /**
     * Retrieves project with the given id.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>. Can not
     *        be null or empty string.
     * @param projectId identifier used to retrieve JIRA project. Can not be null.
     * @return non-null JIRA project retrieval result.
     * @throws IllegalArgumentException if one of the arguments is null or authentication token is
     *         empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    public JiraProjectRetrievalResult getProject(String token, Long projectId) throws JiraManagerException {
        checkString(token, "token");
        checkNotNull(projectId, "projectId");

        JiraProjectRetrievalResult result = null;

        long start = logEntry("getProject", "token", token, "projectId", projectId);
        try {
            // get all available projects
            RemoteProject[] projects = getRemoteProjects(token);
            // search
            RemoteProject remoteProject = null;
            for (RemoteProject existingProject : projects) {
                if (existingProject.getId().equals(projectId.toString())) {
                    remoteProject = existingProject;
                    break;
                }
            }
            JiraProject project = remoteProject == null ? null : convertToLocalProject(remoteProject);

            // create retrieval result
            JiraProjectRetrievalResultAction action =
                project == null ? JiraProjectRetrievalResultAction.PROJECT_NOT_FOUND
                    : JiraProjectRetrievalResultAction.PROJECT_FOUND_NOT_VERSION;
            result = new JiraProjectRetrievalResult(project, null, action);
        } catch (JiraManagerException e) {
            logError("getProject", e);
            throw e;
        }

        logExit("getProject", start, result);
        return result;
    }

    /**
     * Retrieves project with the given key.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>. Can not
     *        be null or empty string.
     * @param projectKey key used to retrieve JIRA project. Can not be null or empty string.
     * @return non-null JIRA project retrieval result.
     * @throws IllegalArgumentException if one of the arguments is null or empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    public JiraProjectRetrievalResult getProject(String token, String projectKey) throws JiraManagerException {
        checkString(token, "token");
        checkString(projectKey, "projectKey");

        JiraProjectRetrievalResult result = null;

        long start = logEntry("getProject", "token", token, "projectKey", projectKey);
        try {
            // get project
            RemoteProject remoteProject = getRemoteProjectByKey(token, projectKey);
            JiraProject project = remoteProject == null ? null : convertToLocalProject(remoteProject);
            // create retrieval result
            JiraProjectRetrievalResultAction action =
                project == null ? JiraProjectRetrievalResultAction.PROJECT_NOT_FOUND
                    : JiraProjectRetrievalResultAction.PROJECT_FOUND_NOT_VERSION;
            result = new JiraProjectRetrievalResult(project, null, action);

        } catch (JiraManagerException e) {
            logError("getProject", e);
            throw e;
        }

        logExit("getProject", start, result);
        return result;
    }

    /**
     * Retrieves project with the given key and version name.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>. Can not
     *        be null or empty string.
     * @param projectKey key used to retrieve JIRA project. Can not be null or empty string.
     * @param versionName version used to retrieve JIRA project. Can not be null or empty string.
     * @return non-null JIRA project retrieval result.
     * @throws IllegalArgumentException if one of the arguments is null or empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    public JiraProjectRetrievalResult getProject(String token, String projectKey, String versionName)
        throws JiraManagerException {
        checkString(token, "token");
        checkString(projectKey, "projectKey");
        checkString(versionName, "versionName");

        JiraProjectRetrievalResult result = null;

        long start =
            logEntry("getProject", "token", token, "projectKey", projectKey, "versionName", versionName);
        try {
            JiraProject project = null;
            JiraVersion version = null;

            // get project
            RemoteProject remoteProject = getRemoteProjectByKey(token, projectKey);
            project = remoteProject == null ? null : convertToLocalProject(remoteProject);

            // get version
            version = null;
            if (project != null) {
                // version can exist only if project exists
                RemoteVersion remoteVersion = getRemoteVersionByName(token, projectKey, versionName);
                version = remoteVersion == null ? null : convertToLocalVersion(remoteVersion);
            }

            // create retrieval result
            JiraProjectRetrievalResultAction action =
                project == null ? JiraProjectRetrievalResultAction.PROJECT_NOT_FOUND : (version == null
                    ? JiraProjectRetrievalResultAction.PROJECT_FOUND_NOT_VERSION
                    : JiraProjectRetrievalResultAction.PROJECT_AND_VERSION_FOUND);
            result = new JiraProjectRetrievalResult(project, version, action);
        } catch (JiraManagerException e) {
            logError("getProject", e);
            throw e;
        }

        logExit("getProject", start, result);
        return result;
    }

    /**
     * Retrieves all versions of the given project.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>. Can not
     *        be null or empty string.
     * @param projectKey key of the project to retrieve versions for. Can not be null or empty
     *        string.
     * @return non-null list of JIRA project versions.
     * @throws IllegalArgumentException if one of the arguments is null or empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation (for example
     *         project doesn't exist).
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    public List<JiraVersion> getProjectVersions(String token, String projectKey) throws JiraManagerException {
        checkString(token, "token");
        checkString(projectKey, "projectKey");

        List<JiraVersion> result = new ArrayList<JiraVersion>();

        long start = logEntry("getProjectVersions", "token", token, "projectKey", projectKey);
        try {
            // get versions
            RemoteVersion[] versions = getRemoteVersionsForProject(token, projectKey);
            // convert RemoteVersion objects to JiraVersion objects

            for (RemoteVersion remoteVersion : versions) {
                result.add(convertToLocalVersion(remoteVersion));
            }
        } catch (JiraManagerException e) {
            logError("getProjectVersions", e);
            throw e;
        }

        logExit("getProjectVersions", start, result);
        return result;
    }

    /**
     * Getter for the object used to interact with JIRA SOAP service.
     *
     * @return non-null underlying service.
     */
    public JiraSoapService getService() {
        return jiraSoapService;
    }

    /**
     * Returns flag that indicates whether the detailed logging (true value) or standard logging
     * (false value) is used.
     *
     * @return flag that indicates whether the detailed logging (true value) or standard logging
     *         (false value) is used.
     */
    public boolean isVerboseLogging() {
        return verboseLogging;
    }

    /**
     * Performs login of the given user with the given password to JIRA system.
     *
     * @param username name of the JIRA user. Can not be null or empty string.
     * @param password password of the JIRA user. Can not be null or empty string.
     * @return an authentication token that can then be used on further SOAP calls to verify whether
     *         the user has access to the areas being manipulated. Will not be null or empty string.
     * @throws IllegalArgumentException if one of the arguments is null or empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if name and password is an invalid combination.
     */
    public String login(String username, String password) throws JiraManagerException {
        checkString(username, "username");
        checkString(password, "password");

        String result = null;

        long start = logEntry("login", "username", username, "password", password);
        try {
            // login
            try {
                result = loginRoutine(username, password);
            } catch (java.rmi.RemoteException e) {
                try {
                    result = loginRoutine(username, password);
                } catch (java.rmi.RemoteException ex) {
                    throw new JiraConnectionException("Unable to establish connection.", ex);
                }
            }
        } catch (JiraManagerException e) {
            logError("login", e);
            throw e;
        }
        logExit("login", start, result);
        return result;

    }

    /**
     * Performs login of the given user with the given password to JIRA system.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param username name of the JIRA user
     * @param password password of the JIRA user
     * @return an authentication token that can then be used on further SOAP calls to verify whether
     *         the user has access to the areas being manipulated. Will not be null or empty string.
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if name and password is an invalid combination.
     */
    private String loginRoutine(String username, String password) throws java.rmi.RemoteException,
        JiraManagerException {
        try {
            return jiraSoapService.login(username, password);
        } catch (RemoteAuthenticationException e) {
            throw new JiraNotAuthorizedException("User name or password is incorrect.", e);
        } catch (RemoteException e) {
            throw new JiraManagerException("Unable to perform login.", e);
        }
    }

    /**
     * Performs logout from JIRA system using the given authentication token.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>. Can not
     *        be null or empty string.
     * @throws IllegalArgumentException if argument is null or empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    public void logout(String token) throws JiraManagerException {
        checkString(token, "token");

        long start = logEntry("logout", "token", token);
        try {
            // logout
            try {
                logoutRoutine(token);
            } catch (java.rmi.RemoteException e) {
                try {
                    logoutRoutine(token);
                } catch (java.rmi.RemoteException ex) {
                    throw new JiraConnectionException("Unable to establish connection.", ex);
                }
            }
        } catch (JiraManagerException e) {
            logError("logout", e);
            throw e;
        }
        logExit("logout", start, "void");
    }

    /**
     * Performs logout from JIRA system.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private void logoutRoutine(String token) throws java.rmi.RemoteException, JiraManagerException {
        try {
            jiraSoapService.logout(token);
        } catch (RemoteException e) {
            // method logout throws only RemoteException so we need to parse fault string
            throw parseRemoteException(e);
        }
    }

    /**
     * Checks whether the project with the given name exists in JIRA system (check is
     * case-insensitive).
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>. Can not
     *        be null or empty string.
     * @param projectName name of the project to check. Can not be null or empty string.
     * @return true if project with the given name exists and false otherwise.
     * @throws IllegalArgumentException if one of the arguments is null or empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    public boolean projectExists(String token, String projectName) throws JiraManagerException {
        checkString(token, "token");
        checkString(projectName, "projectName");

        boolean result = false;

        long start = logEntry("projectExists", "token", token, "projectName", projectName);
        try {
            // get all available projects
            RemoteProject[] projects = getRemoteProjects(token);
            // search
            for (RemoteProject remoteProject : projects) {
                if (remoteProject.getName().equalsIgnoreCase(projectName)) {
                    result = true;
                    break;
                }
            }
        } catch (JiraManagerException e) {
            logError("projectExists", e);
            throw e;
        }
        logExit("projectExists", start, result);

        return result;
    }

    /**
     * Releases specified version of the JIRA project.
     * <p>
     * If user wants to change version state from unreleased to released then he or she must provide
     * release date and set released flag to true.
     * <p>
     * If user wants to change version state from released to unreleased then he or she must set
     * released flag to false.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>. Can not
     *        be null or empty string.
     * @param projectKey key of the project to release. Can not be null or empty string.
     * @param version version of the project to release. Can not be null.
     * @throws IllegalArgumentException if one of the arguments is null or one of the string
     *         arguments is empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation (for example
     *         project or version doesn't exist).
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    public void releaseVersion(String token, String projectKey, JiraVersion version)
        throws JiraManagerException {
        checkString(token, "token");
        checkString(projectKey, "projectKey");
        checkNotNull(version, "version");

        long start = logEntry("releaseVersion", "token", token, "projectKey", projectKey, "version", version);
        try {
            // release version
            try {
                releaseVersionRoutine(token, projectKey, convertToRemoteVersion(version));
            } catch (java.rmi.RemoteException e) {
                try {
                    releaseVersionRoutine(token, projectKey, convertToRemoteVersion(version));
                } catch (java.rmi.RemoteException ex) {
                    throw new JiraConnectionException("Unable to establish connection.", ex);
                }
            }
        } catch (JiraManagerException e) {
            logError("releaseVersion", e);
            throw e;
        }
        logExit("releaseVersion", start, "void");
    }

    /**
     * Releases specified version of the JIRA project.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param projectKey key of the project to release
     * @param version version of the project to release
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private void releaseVersionRoutine(String token, String projectKey, RemoteVersion version)
        throws java.rmi.RemoteException, JiraManagerException {
        try {
            jiraSoapService.releaseVersion(token, projectKey, version);
        } catch (RemoteException e) {
            // method releaseVersion throws only RemoteException so we need to parse fault string
            throw parseRemoteException(e);
        }
    }

    /**
     * Sets object used to perform logging of all manager operations.
     * <p>
     * Null means that logging is disabled.
     *
     * @param log new logger
     */
    public void setLog(Log log) {
        this.log = log;
    }

    /**
     * Updates flag that indicates whether the detailed logging (true value) or standard logging
     * (false value) is used.
     *
     * @param verboseLogging new value of the flag
     */
    public void setVerboseLogging(boolean verboseLogging) {
        this.verboseLogging = verboseLogging;
    }

    /**
     * Updates project in JIRA system.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>. Can not
     *        be null or empty string.
     * @param project entity with properties used to update JIRA project. Can not be null.
     * @return non-null entity with updated properties of the JIRA project.
     * @throws IllegalArgumentException if one of the arguments is null or authentication token is
     *         empty.
     * @throws JiraConnectionException if unable to reestablish connection to JIRA system.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraProjectValidationException if project is incomplete or malformed.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    public JiraProject updateProject(String token, JiraProject project) throws JiraManagerException {
        checkString(token, "token");
        checkNotNull(project, "project");

        JiraProject result = null;

        long start = logEntry("updateProject", "token", token, "project", project);
        try {
            // get existing project (exception will be thrown if project doesn't exist)
            RemoteProject existingProject = getExistingRemoteProjectByKey(token, project.getKey());

            // we need to retrieve current schemes so we need to retrieve project by id
            Long id;
            try {
                id = Long.valueOf(existingProject.getId());
            } catch (NumberFormatException e) {
                // fail-safe check
                throw new JiraManagerException("Project id is not long value.", e);
            }

            // get project with schemes by id
            try {
                existingProject = getProjectWithSchemeByIdRoutine(token, id);
            } catch (java.rmi.RemoteException ex) {
                try {
                    existingProject = getProjectWithSchemeByIdRoutine(token, id);
                } catch (java.rmi.RemoteException e) {
                    throw new JiraConnectionException("Unable to establish connection.", e);
                }
            }

            // convert local project to remote project
            RemoteProject remoteProject = convertToRemoteProject(project);
            // use existing schemes
            remoteProject.setPermissionScheme(existingProject.getPermissionScheme());
            remoteProject.setNotificationScheme(existingProject.getNotificationScheme());
            remoteProject.setIssueSecurityScheme(existingProject.getIssueSecurityScheme());

            // perform update
            result = convertToLocalProject(updateRemoteProject(token, remoteProject));
        } catch (JiraManagerException e) {
            logError("updateProject", e);
            throw e;
        }
        logExit("updateProject", start, result);

        return result;
    }

    /**
     * Retrieves project with the given id from JIRA system. Returned project will contain schemes.
     * <p>
     * This method rethrows <code>java.rmi.RemoteException</code> so that external method can
     * decide whether the reconnection is needed or exception should be raised.
     *
     * @param token SOAP authentication token. It's created by method <code>login</code>.
     * @param projectId id to search project for
     * @return retrieved project or null if project doesn't exist.
     * @throws java.rmi.RemoteException if unable to properly access remote service.
     * @throws JiraManagerException if general error occurs during this operation.
     * @throws JiraNotAuthorizedException if user doesn't have access to the areas being
     *         manipulated.
     * @throws JiraSecurityTokenExpiredException if authentication token expires or becomes stale.
     */
    private RemoteProject getProjectWithSchemeByIdRoutine(String token, Long projectId)
        throws java.rmi.RemoteException, JiraManagerException {
        RemoteProject result;
        try {
            result = jiraSoapService.getProjectWithSchemesById(token, projectId.longValue());
        } catch (RemoteException e) {
            // method getProjectWithSchemesById throws only RemoteException so we need to parse
            // fault string
            throw parseRemoteException(e);
        }

        return result;
    }

    /**
     * Converts <code>RemoteProject</code> to the corresponding <code>JiraProject</code>
     * instance.
     *
     * @param remoteProject <code>RemoteProject</code> instance to convert. Can not be null.
     * @return result of conversion. Will not be null.
     * @throws IllegalArgumentException if argument is null.
     */
    protected JiraProject convertToLocalProject(RemoteProject remoteProject) {
        checkNotNull(remoteProject, "remoteProject");

        // create new instance
        JiraProject jiraProject = new JiraProject();

        // update fields
        jiraProject.setDescription(remoteProject.getDescription());
        jiraProject.setId(remoteProject.getId());
        jiraProject.setKey(remoteProject.getKey());
        jiraProject.setLead(remoteProject.getLead());
        jiraProject.setName(remoteProject.getName());
        jiraProject.setProjectUrl(remoteProject.getProjectUrl());
        jiraProject.setUrl(remoteProject.getUrl());

        return jiraProject;
    }

    /**
     * Converts <code>RemoteVersion</code> to the corresponding <code>JiraVersion</code>
     * instance.
     *
     * @param remoteVersion <code>RemoteVersion</code> instance to convert. Can not be null.
     * @return result of conversion. Will not be null.
     * @throws IllegalArgumentException if argument is null.
     */
    protected JiraVersion convertToLocalVersion(RemoteVersion remoteVersion) {
        checkNotNull(remoteVersion, "remoteVersion");

        // create new instance
        JiraVersion jiraVersion = new JiraVersion();

        // update fields
        jiraVersion.setArchived(remoteVersion.isArchived());
        jiraVersion.setId(remoteVersion.getId());
        jiraVersion.setName(remoteVersion.getName());
        jiraVersion.setReleased(remoteVersion.isReleased());
        if (remoteVersion.getReleaseDate() != null) {
            jiraVersion.setReleaseDate(remoteVersion.getReleaseDate().getTime());
        }
        if (remoteVersion.getSequence() != null) {
            jiraVersion.setSequence(remoteVersion.getSequence().longValue());
        }

        return jiraVersion;
    }

    /**
     * Converts <code>JiraProject</code> to the corresponding <code>RemoteProject</code>
     * instance.
     *
     * @param jiraProject <code>JiraProject</code> instance to convert. Can not be null.
     * @return result of conversion. Will not be null.
     * @throws IllegalArgumentException if argument is null.
     */
    protected RemoteProject convertToRemoteProject(JiraProject jiraProject) {
        checkNotNull(jiraProject, "jiraProject");

        // create new instance
        RemoteProject remoteProject = new RemoteProject();

        // update fields
        remoteProject.setDescription(jiraProject.getDescription());
        remoteProject.setId(jiraProject.getId());
        remoteProject.setKey(jiraProject.getKey());
        remoteProject.setLead(jiraProject.getLead());
        remoteProject.setName(jiraProject.getName());
        remoteProject.setProjectUrl(jiraProject.getProjectUrl());
        remoteProject.setUrl(jiraProject.getUrl());

        return remoteProject;
    }

    /**
     * Converts <code>JiraVersion</code> to the corresponding <code>RemoteVersion</code>
     * instance.
     *
     * @param jiraVersion <code>JiraVersion</code> instance to convert. Can not be null.
     * @return result of conversion. Will not be null.
     * @throws IllegalArgumentException if argument is null.
     */
    protected RemoteVersion convertToRemoteVersion(JiraVersion jiraVersion) {
        checkNotNull(jiraVersion, "jiraVersion");

        // create new instance
        RemoteVersion remoteVersion = new RemoteVersion();

        // update fields
        remoteVersion.setArchived(jiraVersion.isArchived());
        remoteVersion.setId(jiraVersion.getId());
        remoteVersion.setName(jiraVersion.getName());
        remoteVersion.setReleased(jiraVersion.isReleased());
        remoteVersion.setSequence(Long.valueOf(jiraVersion.getSequence()));
        if (jiraVersion.getReleaseDate() != null) {
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(jiraVersion.getReleaseDate());
            remoteVersion.setReleaseDate(calendar);
        }

        return remoteVersion;
    }

    /**
     * Retrieves service stub from the locator and updates corresponding field.
     *
     * @throws JiraManagerException if service couldn't be retrieved from locator.
     */
    private void updateServiceField() throws JiraManagerException {
        try {

            jiraSoapService =
                jiraUrl == null ? serviceLocator.getJirasoapserviceV2() : serviceLocator
                    .getJirasoapserviceV2(jiraUrl);

        } catch (ServiceException e) {
            // wrap it into the JiraManagerException
            throw new JiraManagerException("Unable to get service from locator.", e);
        }
    }

    /**
     * Logs method entry.
     *
     * @param methodName name of the method
     * @param args names and values of the arguments. Objects at even indexes (0, 2, 4...) represent
     *        names while objects at odd indexes (1, 3, 5...) represent corresponding values.
     * @return current timestamp. It will be used to calculate time spent in method.
     */
    private long logEntry(String methodName, Object... args) {
        // if logging is disabled then return right now
        if (log == null) {
            return 0;
        }

        // log method entry
        log.log(Level.DEBUG, "Entering method " + methodName);

        long start = 0;
        // log timestamp if needed
        if (verboseLogging) {
            start = System.currentTimeMillis();
            log.log(Level.DEBUG, "Entry time: " + start);
        }
        // log arguments
        int index = 0;
        Object name = 0;
        for (Object argument : args) {
            if ((index & 1) == 0) {
                name = argument;
            } else {
                log.log(Level.DEBUG, "argument '" + name + "': " + toString(argument));
            }
            index++;
        }

        return start;
    }

    /**
     * Logs occurred error.
     *
     * @param methodName name of the method where error occurs
     * @param cause occurred error
     */
    private void logError(String methodName, Throwable cause) {
        // if logging is disabled then return right now
        if (log == null) {
            return;
        }
        log.log(Level.WARN, cause, "Error occurred in method " + methodName);
    }

    /**
     * Logs method exit.
     *
     * @param methodName name of the method
     * @param startTime time when method was started
     * @param returnValue return value to log
     */
    private void logExit(String methodName, long startTime, Object returnValue) {
        // if logging is disabled or standard logging is used then return right now
        if (log == null || !verboseLogging) {
            return;
        }

        // log elapsed time
        log.log(Level.DEBUG, "Spent time: " + (System.currentTimeMillis() - startTime) + " ms.");
        // log return value
        log.log(Level.DEBUG, "Return value: " + toString(returnValue));
        // log method exit
        log.log(Level.DEBUG, "Exiting method " + methodName);
    }

    /**
     * Utility method used to get string representation of the object.
     * <p>
     * Used for logging.
     *
     * @param obj object to log
     * @return string representation of the passed object.
     */
    private static String toString(Object obj) {
        if (obj instanceof JiraProject) {
            JiraProject project = (JiraProject) obj;
            return "project(id=" + project.getId() + ", key=" + project.getKey() + ", name="
                + project.getName() + ")";
        }
        if (obj instanceof JiraVersion) {
            JiraVersion version = (JiraVersion) obj;
            return "version(id=" + version.getId() + ", name=" + version.getName() + ")";
        }
        if (obj instanceof JiraProjectCreationResult) {
            JiraProjectCreationResult result = (JiraProjectCreationResult) obj;
            return "{" + result.getActionTaken() + ", " + toString(result.getProject()) + ", "
                + toString(result.getVersion()) + "}";
        }
        if (obj instanceof JiraProjectRetrievalResult) {
            JiraProjectRetrievalResult result = (JiraProjectRetrievalResult) obj;
            return "{" + result.getRetrievalResult() + ", " + toString(result.getProject()) + ", "
                + toString(result.getVersion()) + "}";
        }

        return obj == null ? "null" : obj.toString();
    }

    /**
     * Returns a child configuration object with the given name.
     *
     * @param configurationObject configuration object to get child from
     * @param name name of the child
     * @return child configuration object
     * @throws JiraManagerConfigurationException if error occurs while retrieving the child.
     */
    private static ConfigurationObject retrieveChild(ConfigurationObject configurationObject, String name) {
        ConfigurationObject child;
        // get child by name
        try {
            child = configurationObject.getChild(name);
        } catch (ConfigurationAccessException e) {
            throw new JiraManagerConfigurationException("Unable to retrieve child with name '" + name + "'.",
                e);
        }
        return child;
    }

    /**
     * Returns string property value for the given key.
     *
     * @param configurationObject configuration object to get property from
     * @param name name of the property
     * @param canBeNullOrEmpty flag that indicates whether the value can be null or empty string
     * @return property value for the given key. If value is empty string then null will be
     *         returned.
     * @throws JiraManagerConfigurationException if error occurs while retrieving the value; if
     *         value is null or empty and canBeNullOrEmpty flag is false; if value is not a String
     *         instance.
     */
    private static String retrievePropertyValue(ConfigurationObject configurationObject, String name,
        boolean canBeNullOrEmpty) {
        Object value;

        // get value
        try {
            if (configurationObject.getPropertyValuesCount(name) > 1) {
                throw new JiraManagerConfigurationException("Property '" + name
                    + "' couldn't have more than one value.");
            }
            value = configurationObject.getPropertyValue(name);
        } catch (ConfigurationAccessException e) {
            throw new JiraManagerConfigurationException("Unable to retrieve property with name '" + name
                + "'.", e);

        }

        // make sure that value is a String instance
        String stringValue;
        try {
            stringValue = (String) value;
        } catch (ClassCastException e) {
            throw new JiraManagerConfigurationException("Value of the property must be String object.", e);
        }

        // check whether value is null or empty
        if ((stringValue == null || stringValue.trim().length() == 0) && !canBeNullOrEmpty) {
            throw new JiraManagerConfigurationException("Property '" + name + "' couldn't be null or empty.");
        }

        return stringValue;
    }

    /**
     * Reads mapping from configuration.
     *
     * @param configurationObject configuration object to get data from
     * @param map map to read data in
     * @param namespace child configuration object with data for concrete mapping
     * @param defaultMap default mapping to use if child configuration doesn't exist
     * @throws JiraManagerConfigurationException if configuration data invalid.
     */
    private static void readMapping(ConfigurationObject configurationObject, Map<ComponentType, String> map,
        String namespace, Map<ComponentType, String> defaultMap) {
        // get configuration namespace
        ConfigurationObject child = retrieveChild(configurationObject, namespace);
        if (child == null) {
            map.putAll(defaultMap);
            return;
        }

        // read mappings
        map.put(ComponentType.APPLICATION, retrievePropertyValue(child, APPLICATION_TOKEN_KEY, false));
        map.put(ComponentType.CUSTOM_COMPONENT, retrievePropertyValue(child, CUSTOM_TOKEN_KEY, false));
        map.put(ComponentType.GENERIC_COMPONENT, retrievePropertyValue(child, GENERIC_TOKEN_KEY, false));
    }

    /**
     * Wraps given remote exception into the corresponding <code>JiraManagerException</code>
     * instance.
     * <p>
     * Methods checks fault string for 'RemoteAuthenticationException', 'RemoteValidationException'
     * or 'RemotePermissionException' substring. If one of these strings is found then corresponding
     * <code>JiraSecurityTokenExpiredException</code>,
     * <code>JiraProjectValidationException</code> or <code>JiraNotAuthorizedException</code> is
     * thrown. If none were found then exception is wrapped into the
     * <code>JiraManagerException</code>
     *
     * @param e caught exception
     * @return JiraManagerException wrapper around the passed exception.
     */
    private static JiraManagerException parseRemoteException(RemoteException e) {
        // we have to parse message
        if (e.getFaultString().contains("RemoteAuthenticationException")) {
            return new JiraSecurityTokenExpiredException("Authentication token is invalid.", e);
        }
        if (e.getFaultString().contains("RemoteValidationException")) {
            return new JiraProjectValidationException("Validation error occurred.", e);
        }
        if (e.getFaultString().contains("RemotePermissionException")) {
            return new JiraNotAuthorizedException("User doesn't have permissions to perform operation.", e);
        }
        return new JiraManagerException("Unable to perform operation due to general remote exception", e);
    }

    /**
     * Creates configuration object from the given file and namespace.
     *
     * @param filename name of the configuration file. Can not be null or empty string.
     * @param namespace namespace. Can not be null or empty string.
     * @return configuration object representing given namespace from the given file.
     * @throws IllegalArgumentException if one of the arguments is null or empty.
     * @throws JiraManagerConfigurationException if configuration data are invalid.
     */
    private static ConfigurationObject getConfigurationObject(String filename, String namespace) {
        checkString(filename, "filename");
        checkString(namespace, "namespace");
        try {
            return new ConfigurationFileManager(filename).getConfiguration(namespace);
        } catch (ConfigurationPersistenceException e) {
            throw new JiraManagerConfigurationException("Configuration data are invalid.", e);
        } catch (IOException e) {
            throw new JiraManagerConfigurationException("I/O error occurred while reading configuration.", e);
        }
    }

    /**
     * Checks whether this map contains mappings for all component types.
     *
     * @param map the map to check
     * @param paramName the actual parameter name of the argument being checked
     * @throws IllegalArgumentException if map is not null and doesn't contain mapping for every
     *         component type; if map is not null and contains mapping not only for component types;
     *         if map values are null or empty string.
     */
    private static void checkMap(Map<ComponentType, String> map, String paramName) {
        // ignore null map
        if (map == null) {
            return;
        }
        // check size
        if (map.size() != ComponentType.values().length) {
            throw new IllegalArgumentException("Map " + paramName
                + " doesn't contain mapping for every component type.");
        }
        // check keys and values
        for (ComponentType type : ComponentType.values()) {
            String value = map.get(type);
            if (value == null) {
                throw new IllegalArgumentException("Map " + paramName + " couldn't contain null values.");
            }
            if (value.trim().length() == 0) {
                throw new IllegalArgumentException("Map " + paramName + " couldn't contain empty values.");
            }
        }
    }

    /**
     * Checks whether the given object is null.
     *
     * @param obj the object to check
     * @param paramName the actual parameter name of the argument being checked
     * @throws IllegalArgumentException if object is null.
     */
    private static void checkNotNull(Object obj, String paramName) {
        if (obj == null) {
            throw new IllegalArgumentException("Argument " + paramName + " cannot be null.");
        }
    }

    /**
     * Checks whether the given string is null or empty.
     *
     * @param str the string to check
     * @param paramName the actual parameter name of the argument being checked
     * @throws IllegalArgumentException if argument is null or empty.
     */
    private static void checkString(String str, String paramName) {
        checkNotNull(str, paramName);
        if (str.trim().length() == 0) {
            throw new IllegalArgumentException("Argument " + paramName + " must be non-empty string.");
        }
    }

}
