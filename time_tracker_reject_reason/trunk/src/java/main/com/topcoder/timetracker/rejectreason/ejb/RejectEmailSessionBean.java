/*
 * Copyright (C) 2007 TopCoder Inc., All Rights Reserved.
 */
package com.topcoder.timetracker.rejectreason.ejb;

import com.topcoder.search.builder.filter.Filter;

import com.topcoder.timetracker.rejectreason.RejectEmail;
import com.topcoder.timetracker.rejectreason.RejectEmailDAO;
import com.topcoder.timetracker.rejectreason.RejectEmailDAOException;

import com.topcoder.util.errorhandling.BaseException;

import javax.ejb.SessionBean;
import javax.ejb.SessionContext;

/**
 * <p>
 * This is a Stateless SessionBean that is used to provided business services to manage RejectEmailes within the Time
 * Tracker Application. It contains all methods in RejectEmailDAO interface, and delegates to an instance of
 * RejectEmailDAO.
 * </p>
 *
 * <p>
 * The instance of RejectEmailDAO to use is stored in the class variable DAO, and are warned to be access only via
 * protected method getDAO (in this method the DAO is checked, if it is null then create a new one).
 * </p>
 *
 * <p>
 * <b>Thread Safety:</b> The RejectEmailDAO interface implementations are required to be thread-safe, and so this
 * stateless session bean is thread-safe also. And this bean is a Container Managed Transaction session bean with
 * trans-attribute as &quot;Required&quot; in the deploy descriptor (see the example deploy descriptor of this ejb).
 * </p>
 *
 * @author wangqing, TCSDEVELOPER
 * @version 3.2
 */
public class RejectEmailSessionBean implements RejectEmailDAO, SessionBean {

	/**
	 * Automatically generated unique ID for use with serialization.
	 */
	private static final long serialVersionUID = 7148295033252127282L;

	/**
     * <p>
     * This is the instance of RejectEmailDAO that this session bean delegates all the work to. It is a private class
     * variable that should not be access directly even within, instead use getDAO method to get it. That's because we
     * need the getDAO method to make sure the RejectEmailDAO is properly initialized no matter under what situation
     * (the session bean can be passivate and then activate, and can be created newly) there should be a and only one
     * RejectEmailDAO the session bean can delegate its tasks to.
     * </p>
     */
    private static transient RejectEmailDAO dao = null;

    /**
     * <p>
     * This is the instance of SessionContext that was provided by the EJB container. It is stored and made available
     * to subclasses.
     * </p>
     */
    private SessionContext sessionContext = null;

    /**
     * <p>
     * Default constructor.
     * </p>
     */
    public RejectEmailSessionBean() {
        // Empty
    }

    /**
     * <p>
     * This method is invoked by the container when the instance is in the process of being added by the container.
     * </p>
     *
     * <p>
     * <b>Note:</b> For current implementation is empty.
     * </p>
     */
    public void ejbCreate() {
        // Empty
    }

    /**
     * <p>
     * This method is invoked by the container when it wants to activate the instance.
     * </p>
     *
     * <p>
     * <b>Note:</b> For current implementation is empty.
     * </p>
     */
    public void ejbActivate() {
        // Empty
    }

    /**
     * <p>
     * This method is invoked by the container when it wants to passivate the instance.
     * </p>
     *
     * <p>
     * <b>Note:</b> For current implementation is empty.
     * </p>
     */
    public void ejbPassivate() {
        // Empty
    }

    /**
     * <p>
     * This method is invoked by the container when it wants to Remove the instance.
     * </p>
     *
     * <p>
     * <b>Note:</b> For current implementation is empty.
     * </p>
     */
    public void ejbRemove() {
        // Empty
    }

    /**
     * <p>
     * Sets the SessionContext to use for this session. This method is included to comply with the SessionBean
     * interface.
     * </p>
     *
     * @param sessionContext the session context to set.
     */
    public void setSessionContext(SessionContext sessionContext) {
        this.sessionContext = sessionContext;
    }

    /**
     * <p>
     * Creates a data store entry for the given Reject Email. An id is automatically generated by the DAO and assigned
     * to the Email. The RejectEmail is also considered to have been created by the specified username. If the
     * argument isAudit is true, insert the corresponding audit record in data store.
     * </p>
     *
     * @param rejectEmail the rejectEmail to create within the data store.
     * @param username the username of the user responsible for creating the RejectEmail entry within the data store.
     * @param isAudit indicates audit or not.
     *
     * @return the same rejectEmail Object, with an assigned id, creationDate, modificationDate, creationUser and
     *         modificationUser assigned appropriately.
     *
     * @throws IllegalArgumentException if the rejectEmail or username is null, or if username is an empty String, or
     *         the company id or body of the passed in reject email is not set.
     * @throws RejectEmailDAOException if a problem occurs while accessing the data store.
     * @throws RejectEmailDAOConfigurationException if any required environment variables can't be found.
     */
    public RejectEmail createRejectEmail(RejectEmail rejectEmail, String username, boolean isAudit)
        throws RejectEmailDAOException {
        try {
            return getDAO().createRejectEmail(rejectEmail, username, isAudit);
        } catch (IllegalArgumentException e) {
            sessionContext.setRollbackOnly();
            throw e;
        } catch (RejectEmailDAOException e) {
            sessionContext.setRollbackOnly();
            throw e;
        }
    }

    /**
     * <p>
     * Retrieves a RejectEmail from the data store with the provided id. If no RejectEmail with that id exists, then a
     * null is returned.
     * </p>
     *
     * @param id the id of the RejectEmail to retrieve from the data store.
     *
     * @return the retrieved RejectEmail object or null if there is no corresponding RejectEmail.
     *
     * @throws IllegalArgumentException if id is less than or equals to zero.
     * @throws RejectEmailDAOException if a problem occurs while accessing the data store.
     * @throws RejectEmailDAOConfigurationException if any required environment variables can't be found.
     */
    public RejectEmail retrieveRejectEmail(long id) throws RejectEmailDAOException {
        try {
            return getDAO().retrieveRejectEmail(id);
        } catch (IllegalArgumentException e) {
            sessionContext.setRollbackOnly();
            throw e;
        } catch (RejectEmailDAOException e) {
            sessionContext.setRollbackOnly();
            throw e;
        }
    }

    /**
     * <p>
     * Updates the given RejectEmail in the data store. The RejectEmail is considered to have been modified by the
     * specified username. If the argument isAudit is true, insert the corresponding audit record in data store.
     * </p>
     *
     * @param rejectEmail the RejectEmail entity to modify.
     * @param username the username of the user responsible for performing the update.
     * @param isAudit indicates audit or not.
     *
     * @throws IllegalArgumentException if the rejectEmail or username is null, or if username is an empty String, or
     *         if the body of rejectEmail is not set.
     * @throws RejectEmailDAOException if a problem occurs while accessing the data store.
     * @throws RejectEmailNotFoundException if the RejectEmail to update was not found in the data store.
     * @throws RejectEmailDAOConfigurationException if any required environment variables can't be found.
     */
    public void updateRejectEmail(RejectEmail rejectEmail, String username, boolean isAudit)
        throws RejectEmailDAOException {
        try {
            getDAO().updateRejectEmail(rejectEmail, username, isAudit);
        } catch (IllegalArgumentException e) {
            sessionContext.setRollbackOnly();
            throw e;
        } catch (RejectEmailDAOException e) {
            sessionContext.setRollbackOnly();
            throw e;
        }
    }

    /**
     * <p>
     * Removes the specified RejectEmail from the data store. If the argument isAudit is true, insert the corresponding
     * audit record in data store.
     * </p>
     *
     * @param rejectEmail the rejectEmail to delete.
     * @param username the username of the user responsible for performing the deletion.
     * @param isAudit indicates audit or not.
     *
     * @throws IllegalArgumentException if the rejectEmail is null.
     * @throws RejectEmailDAOException if a problem occurs while accessing the data store.
     * @throws RejectEmailNotFoundException if the RejectEmail to delete was not found in the data store.
     * @throws RejectEmailDAOConfigurationException if any required environment variables can't be found.
     */
    public void deleteRejectEmail(RejectEmail rejectEmail, String username, boolean isAudit)
        throws RejectEmailDAOException {
        try {
            getDAO().deleteRejectEmail(rejectEmail, username, isAudit);
        } catch (IllegalArgumentException e) {
            sessionContext.setRollbackOnly();
            throw e;
        } catch (RejectEmailDAOException e) {
            sessionContext.setRollbackOnly();
            throw e;
        }
    }

    /**
     * <p>
     * Enumerates all the RejectEmails that are present within the data store. If no record found an empty array will
     * be return.
     * </p>
     *
     * @return a list of all the RejectEmails within the data store.
     *
     * @throws RejectEmailDAOException if a problem occurs while accessing the datastore.
     * @throws RejectEmailDAOConfigurationException if any required environment variables can't be found.
     */
    public RejectEmail[] listRejectEmails() throws RejectEmailDAOException {
        try {
            return getDAO().listRejectEmails();
        } catch (RejectEmailDAOException e) {
            sessionContext.setRollbackOnly();
            throw e;
        }
    }

    /**
     * <p>
     * Returns a list of all the RejectEmails within the data store that satisfy the filters that are provided. If no
     * record found an empty array will be return. The filters are defined using classes from the Search Builder
     * component.
     * </p>
     *
     * @param filter the filter that is used as criterion to facilitate the search.
     *
     * @return a list of RejectEmails that satisfy the search criterion.
     *
     * @throws IllegalArgumentException if the filter is null.
     * @throws RejectEmailDAOException if a problem occurs while accessing the datastore.
     * @throws RejectEmailDAOConfigurationException if any required environment variables can't be found.
     */
    public RejectEmail[] searchRejectEmails(Filter filter)
        throws RejectEmailDAOException {
        try {
            return getDAO().searchRejectEmails(filter);
        } catch (IllegalArgumentException e) {
            sessionContext.setRollbackOnly();
            throw e;
        } catch (RejectEmailDAOException e) {
            sessionContext.setRollbackOnly();
            throw e;
        }
    }

    /**
     * <p>
     * Gets the SessionContext used by this session.
     * </p>
     *
     * @return the session context used by this session.
     */
    protected SessionContext getSessionContext() {
        return sessionContext;
    }

    /**
     * <p>
     * Gets the RejectEmailDAO this session bean delegates all the work to.
     * </p>
     *
     * @return the RejectEmailDAO this session bean delegates all the work to.
     *
     * @throws RejectEmailDAOConfigurationException if any required environment variables can't be found or if they are
     *         invalid.
     */
    protected RejectEmailDAO getDAO() throws RejectEmailDAOConfigurationException {
        if (dao == null) {
            // Create new RejectReasonDAO object.
            try {
                dao = (RejectEmailDAO) DAOFactory.getDAO(true);
            } catch (BaseException e) {
                throw new RejectEmailDAOConfigurationException(e.getMessage(), e.getCause());
            }
        }

        return dao;
    }
}
