{\rtf1\ansi\ansicpg1251\deff0\deflang1049\deflangfe1049{\fonttbl{\f0\fswiss\fprq2\fcharset204{\*\fname Arial;}Arial CYR;}{\f1\froman\fprq2\fcharset2 Symbol;}{\f2\froman\fprq2\fcharset204{\*\fname Times New Roman;}Times New Roman CYR;}{\f3\fswiss\fprq2\fcharset0 Arial;}{\f4\froman\fprq2\fcharset0 Times New Roman;}{\f5\fmodern\fprq1\fcharset0 Courier New;}{\f6\fmodern\fprq1\fcharset204{\*\fname Courier New;}Courier New CYR;}}
{\colortbl ;\red0\green0\blue255;\red0\green0\blue0;}
{\stylesheet{ Normal;}{\s1 heading 1;}{\s2 heading 2;}}
{\*\generator Msftedit 5.41.15.1507;}\viewkind4\uc1\pard\keepn\nowidctlpar\s1\sb120\sa60\sl240\slmult0\tx720\ul\b\f0\fs28 Catalog Services 1.0 Component Specification\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\ulnone\b0\fs20\par
\pard\keepn\nowidctlpar\s1\sb120\sa60\sl240\slmult0\tx360\lang1033\b\f1\fs24 1.\tab\lang1049\f0 Design\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\b0\fs20 The Catalog stores information about TopCoder components and applications.\par
This component will provide services for the Catalog.  The services implementation is pluggable, and provides an implementation based on Catalog Entities component, which defines entities and the O/R mapping.\par
This design uses EJB 3.0 and EntityManager to fulfill requirements.\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\b 1.1\tab Design Patterns \par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\b0 None.\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\b 1.2\tab Industry Standards \par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\b0 XML\par
JPA\par
Hibernate\par
JBoss\par
Informix Database\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\b 1.3\tab Required Algorithms\par
\pard\nowidctlpar\tx0\b0\i\f2\fs24 1.3.1Component to AssetDTO\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\i0\f0\fs20 This is the mapping of the DTO fields:\par
\pard\nowidctlpar\fi-360\li1440\sa120\sl238\slmult0\u9679?\tab name   <--->   Component.name\par
\u9679?\tab clientIds   <--->   List<Component.clients.clientId> [optional]\par
\u9679?\tab versionText   <--->   CompVersion.versionText\par
\u9679?\tab shortDescription   <--->   Component.shortDesc\par
\u9679?\tab detailedDescription   <--->   Component.description\par
\u9679?\tab functionalDescription   <--->   Component.functionalDesc\par
\u9679?\tab rootCategory   <--->   Component.rootCategory\par
\u9679?\tab categories   <--->   Component.categories\par
\u9679?\tab technologies   <--->   CompVersion.technologies\par
\u9679?\tab productionDate   <--->   CompVersion.versionDates(phase.id).productionDate [optional]\par
\u9679?\tab link   <--->   CompVersion.link [optional]\par
\u9679?\tab forum   <--->   CompVersion.forum [optional]\par
\u9679?\tab currentLatest   <--->   whether the currentVersion is also the latest [optional]\par
\u9679?\tab id   <--->   Component.id [optional]\par
\u9679?\tab versionId   <--->   CompVersion.id [optional]\par
\u9679?\tab userIds   <--->   List<Component.users.userId> [optional]\par
\u9679?\tab informationComplete:boolean   <--->   wheter the information in the DTO is complete or partial [optional]\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0 The user can choose to retrieve the current or the latest version. To get the current version access Component.currentVersion. To get the latest one just p\tab ick in Component.versions the one with the highest version field. This can be done either via query or by getting Component.versions and comparing dates. It is left to developer the choice of which approach to take, keeping in mind that the goal is performance.\par
\pard\nowidctlpar\i\f2\fs24 1.3.2 AssetDTO to Component\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\i0\f0\fs20 The mapping of course is the same as in 1.3.1. ClientId, productionDate, link and forum When doing the translation, take into account the following:\par
Component entity\par
\pard\nowidctlpar\fi-360\li1440\sa120\sl238\slmult0\u9679?\tab Set status to Status.REQUESTED\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0 CompVersion Entity\par
\pard\nowidctlpar\fi-360\li1440\sa120\sl238\slmult0\u9679?\tab Set phaseTime to 1976-05-05\par
\u9679?\tab Set phasePrice to 0\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0 CompVersionDates entity\par
\pard\nowidctlpar\fi-360\li1440\sa120\sl238\slmult0\u9679?\tab Just create an entry for the collaboration phase (phase_id=111)\par
\u9679?\tab Set totalSubmissions to 0\par
\u9679?\tab Set price to 0\par
\u9679?\tab Set productionDate to the specified value, or null if not specified\par
\u9679?\tab Set postingDate to 1976-05-05\par
\u9679?\tab Set all the other dates to 2000-01-01\par
\u9679?\tab Set levelId to 100\par
\u9679?\tab Set status to Status.NEW_POST\par
\u9679?\tab Leave all the comments fields in null\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\par
\pard\nowidctlpar\i\f2\fs24 1.3.3Find components\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\i0\f0\fs20 When creating the query, keep in mind that only non-null\lang1033\f3  and not empty\lang1049\f0  parameters are considered, so the actual query String \lang1033\f3 is created\lang1049\f0  at runtime. \par
\lang1033\f3 It's implemented in a single query with various number of joins and dynamically built 'where' clause. The example of the queries:\par
\par
1. When only SearchCriteria.description is set (for the current version):\par
\cf1 select A.component_id, A.component_name, A.short_desc, A.root_category_id, B.version_text, B.comp_vers_id from comp_catalog A\par
\tab join comp_versions B on \i A.current_version=B.comp_vers_id\i0\par
\tab  where A.component_id in (\b select distinct C.component_id from comp_catalog C where (lower(C.description) like '%description%')\b0 )\par
\cf2 The bold part is dynamically build part which selects Component.componentIds eligible for the retrieval.\par
Then main query which takes only necessary properties filters Cmponent's ids using 'in'.\par
In this case shown join between comp_versions and comp_catalog by current_version field (when assets for the current version demanded).\par
For example, here more complex query with filtering by clientId and name (for the latest version):\par
\cf1 select A.component_id, A.component_name, A.short_desc, A.root_category_id, B.version_text, B.comp_vers_id from comp_catalog A\par
\tab join comp_versions B on \i A.component_id=B.component_id\par
\i0\tab  where A.component_id in (select distinct C.component_id from comp_catalog C\par
\tab\tab\tab\tab\tab join comp_client CL on CL.component_id=C.component_id\par
\tab\tab\tab\tab\tab  where (CL.client_id=?) and (lower(C.component_name) like '%some service%'))\par
\tab and version=(\b select max(version) from comp_versions where component_id=A.component_id\b0 )\par
\cf2 Here added a join to the comp_client table, and the taken version is the max for each component (\b bold\b0  selection).\par
Join to versions is performed by 'component_id' from 'comp_version' table (\i italic \i0 selection).\par
\par
In the most complex case (when all search criterias are entered):\par
\cf1 select A.component_id, A.component_name, A.short_desc, A.root_category_id, B.version_text, B.comp_vers_id from comp_catalog A\par
\tab join comp_versions B on A.current_version=B.comp_vers_id\par
\tab  where A.component_id in (select distinct C.component_id from comp_catalog C\par
\tab\tab left outer join comp_user U on C.component_id=U.component_id\par
\tab\tab left outer join comp_client CL on CL.component_id=C.component_id\par
\tab\tab left outer join user_client UC on UC.client_id=CL.client_id\par
\tab\tab  where (U.user_id=\i 1011 \i0 OR UC.user_id=\i 1011\i0 )\par
\tab\tab\tab  AND (CL.client_id=\i 562\i0 )\par
\tab\tab\tab  AND (lower(C.component_name) like '%\i a\i0  \i service\i0 %')\par
\tab\tab\tab  AND (lower(C.description) like '%\i ejb\i0 %')\par
\tab\tab\tab  AND (C.root_category_id in (\i 12,14\i0 )))\cf2\par
All possible variations of parameters tested by method of full enumeration.\par
The algorithm of building the query is the following:\par
1. Build query for extracting IDs of eligible components\par
\tab 1.1. If searchCriteria.userId is set add three joins to comp_user, comp_client and user_client tables and one where clause \cf1 comp_user.user_id=?\i  \i0 OR user_client.user_id=?\par
\tab\cf2 1.2. If searchCriteria.clientId is set then if no userId set add join to comp_client (otherwise it was added in 1.1). Add where clause \cf1 comp_client..client_id=?\par
\tab\cf2 1.3  If searchCriteria.name is set then and not empty add  where clause \cf1 (lower(comp_catalog.component_name) like '%\i ?\i0 %')\par
\tab\cf2 1.4  If searchCriteria.description is set  and not empty thenadd  where clause\cf1  (lower(comp_catalog.description) like '%\i ?\i0 %') \cf2 (add OR for each of the others descriptions)\cf1\par
\tab\cf2 1.5  If searchCriteria.categories is set then add  where clause \cf1 (comp_catalog.root_category_id in (\i ?,?, ...\i0 )) (? - for each category)\cf2\par
2. if currentVersion then build query with join by \cf1 comp_catalog.current_version=comp_versions.comp_vers_id\cf2 , otherwise by \cf1 comp_catalog.component_id=comp_versions.component_id\par
\cf2 3. Build whole query using parts made in 2 and 3.\par
4. If not 'currentVersion', add where clause '\cf1 version=(\b select max(version) from comp_versions where component_id=A.component_id\b0 )'\par
\cf2 5. Add special hibernate-mapping for the native query:\par
\cf1 <class name="com.topcoder.catalog.service.AssetDTO" abstract="true">\par
        <id name="id" column="component_id"/>\par
        <property name="versionId" column="comp_vers_id"/>\par
        <property name="name" column="component_name"/>\par
        <property name="shortDescription" column="short_desc"/>\par
        <property name="versionText" column="version_text"/>\par
        <many-to-one name="rootCategory" column="root_category_id"/>\par
    </class>\par
\cf2 Execute query with hint \cf1 query.setHint("org.hibernate.readOnly", true) \cf2 to indicate that it's a read-only entity.\cf1\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\cf0\b\tab\lang1049\f0\par
1.4\tab Component Class Overview\par
\pard\nowidctlpar\f2\fs24\tab CatalogServices\b0 :\par
\pard\nowidctlpar\li1670\sa120\sl238\slmult0\f0\fs20 This interface defines the contract for the catalog services. It provides various ways to get Components, Categories, Technologies and Phases and to modify/update Components from/to database.\b\par
\b0 It uses AssetDTO in order to provide Component information.\par
\lang1033\f3 Implementations should be thread-safe.\lang1049\f0\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\b\par
\pard\nowidctlpar\f2\fs24\tab CatalogServicesLocal\b0  :\par
\pard\nowidctlpar\li1670\sa120\sl238\slmult0\f0\fs20 This interface defines the contract for the catalog services for local use. It provides various ways to get Components, Categories, Technologies and Phases and to modify/update Components from/to database.\par
It uses AssetDTO in order to provide Component information.\par
\lang1033\f3 Implementations should be thread-safe.\lang1049\f0\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\par
\pard\nowidctlpar\b\f2\fs24\tab CatalogServicesRemote\b0  :\par
\pard\nowidctlpar\li1670\sa120\sl238\slmult0\f0\fs20 This interface defines the contract for the catalog services for remote use. It provides various ways to get Components, Categories, Technologies and Phases and to modify/update Components from/to database.\b\par
\b0 It uses AssetDTO in order to provide Component information.\par
\lang1033\f3 Implementations should be thread-safe.\lang1049\f0\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\b\par
\pard\nowidctlpar\f2\fs24\tab CatalogServices\lang1033\f4 Impl\lang1049\b0\f2  :\par
\pard\nowidctlpar\li1670\sa120\sl238\slmult0\f0\fs20 This stateless session bean realizes both local and remote interfaces for the catalog services. It provides various ways to get Components, Categories, Technologies and Phases and to modify/update Components from/to database.\par
It uses AssetDTO in order to provide Component information. This implementation uses entity manager to access persistence.\par
\lang1033\f3 Class is thread-safe.\lang1049\f0\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\par
\pard\nowidctlpar\b\f2\fs24\tab AssetDTO\b0  :\par
\pard\nowidctlpar\li1670\sa120\sl238\slmult0\f0\fs20 This class is a simple DTO that provide a representation of a component that is closer to business requirements than persistent entities are.\b\par
\b0 It provides getter and setter for each field.\line\lang1033\f3 Class is not thread-safe.\lang1049\f0\par
\par
\pard\nowidctlpar\lang1033\b\f4\fs24            SearchCriteria\lang1049\b0\f2  :\par
\pard\nowidctlpar\li1670\sa120\sl238\slmult0\f0\fs20 This class represents the search criteria that is used when finding assets.\par
\lang1033\f3 It should have at least on applicable for search property (non-null and not empty). All fields are initialized in the constructor.\par
Class is thread-safe.\lang1049\f0\par
\b\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0 1.5\tab Component Exception Definitions\par
\pard\nowidctlpar\b0\f2\fs24\tab\b EntityNotFoundException \b0 :\par
\pard\nowidctlpar\li1681\sa120\sl238\slmult0\f0\fs20 This exception is thrown by CatalogServices whenever an entity is not found in persistence\lang1033\f3 .\par
\pard\nowidctlpar\li1670\sa120\sl238\slmult0 Class is not thread-safe.\lang1049\f0\par
\pard\nowidctlpar\li1681\sa120\sl238\slmult0\par
\pard\nowidctlpar\b\f2\fs24\tab PersistenceException \b0 :\par
\pard\nowidctlpar\li1681\sa120\sl238\slmult0\f0\fs20 This exception is thrown by CatalogServices whenever an error occurs when interacting with persistence\lang1033\f3 .\par
\pard\nowidctlpar\li1670\sa120\sl238\slmult0 Class is not thread-safe.\lang1049\b\f0\par
\pard\nowidctlpar\li1681\sa120\sl238\slmult0\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0 1.6\tab Thread Safety\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\b0 This component is not thread safe, because AssetDTO is not thread safe, nor are the entities defined in Catalog Entities. CatalogServices\lang1033\f3 Impl\lang1049\f0  is thread\lang1033\f3 -\lang1049\f0 safe because it is a stateless session bean and access to persistence is done within transactions.\b\par
\b0 AssetDTO should never be used in several threads like the other entities so it should not affect thread safety of services. In such case component is thread safe.\b\par
\pard\keepn\nowidctlpar\s1\sb120\sa60\sl240\slmult0\tx360\lang1033\f1\fs24 2.\tab\lang1049\f0 Environment Requirements\tab\tab\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\fs20 2.1\tab Environment\par
\pard\nowidctlpar\fi-360\li1080\lang1033\b0\f1\fs24\'b7\tab\lang1049\f2 At minimum, Java1.5 is required for compilation and executing test cases.\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\b\f0\fs20 2.2\tab TopCoder Software Components\par
\pard\nowidctlpar\fi-360\li720\sa120\sl238\slmult0\cf2\b0\u9679?\tab\b Catalog Entities 1.0:\b0  defines the entities used in this component.\b\par
\b0\u9679?\tab\b Base Exception 2.0:\b0  used to define custom exception.\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\cf0\b 2.3\tab Third Party Components\par
\pard\nowidctlpar\sa120\sl238\slmult0\cf2\b0 None.\b\par
\pard\keepn\nowidctlpar\s1\sb120\sa60\sl240\slmult0\tx360\cf0\lang1033\f1\fs24 3.\tab\lang1049\f0 Installation and Configuration\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\fs20 3.1\tab Package Name\par
\pard\nowidctlpar\li720\sa120\sl240\slmult0\cf2\b0\i com.topcoder.catalog.service\b\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\cf0\i0 3.2\tab Configuration Parameters\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\b0 None.\b\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0 3.3\tab Dependencies Configuration\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\b0 None.\b\par
\pard\keepn\nowidctlpar\s1\sb120\sa60\sl240\slmult0\tx360\lang1033\f1\fs24 4.\tab\lang1049\f0 Usage Notes\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\fs20 4.1\tab Required steps to test the component\par
\pard\nowidctlpar\fi-360\li1080\sa120\sl238\slmult0\lang1033\b0\f1\'b7\tab\lang1049\f0 Extract the component distribution.\b\par
\lang1033\b0\f1\'b7\tab\lang1049\f0 Execute \lquote ant test\rquote  within the directory that the distribution was extracted to.\b\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0 4.2\tab Required steps to use the component\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\b0 Follow demo.\b\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0 4.3\tab Demo\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0 Obtaining CatalogServices interfaces\par
\b0 Whether you need the local interface or the remote, you can obtain looking up the initial context:\par
\par
public CatalogService getCatalogService(\lang1033\f3 ) \{\lang1049\b\f0\par
\lang1033\b0\f5\fs16\tab\lang1049\f6 try \{\par
\lang1033\f5\tab\lang1049\f6     // get object from JNDI\par
\lang1033\f5\tab\lang1049\f6     Context context = new InitialContext();\par
\lang1033\f5\tab\lang1049\f6     return (CatalogService) context.lookup(\ldblquote CatalogService/remote\rdblquote ); // or \ldblquote CatalogService/local\rdblquote  if CatalogService is in the same EAR file\par
\lang1033\f5\tab\lang1049\f6\} catch (NamingException e) \{\par
\lang1033\f5\tab\lang1049\f6     throw new IllegalStateException(\par
\lang1033\f5\tab\lang1049\f6         "Cannot lookup 'CatalogService'. Check the configuration (Jboss is running, "\par
\lang1033\f5\tab\lang1049\f6             + "id_generator_ejb.jar and catalog_services_ejb.jar are deployed successfully). " + "The nested exception is: " + e.getMessage(), e);\par
\lang1033\f5\tab\lang1049\f6\}\par
\lang1033\f5\}\lang1049\f6\par
\f0\fs20 Services can be used like normal methods, and it unnecessary to enumerate all of them.\b\par
\par
Create a new \lang1033\f3 asset\lang1049\f0\par
\b0\f6\fs16 AssetDTO newAsset = new AssetDTO();\par
newAsset.setName("Catalog Services");\par
newAsset.setVersionText("1.0");\par
newAsset.setShortDescription("short");\par
newAsset.setDetailedDescription("detailed");\par
newAsset.setFunctionalDescription("functional");\par
// set the root category (categories are in the database\par
newAsset.setRootCategory(javaCategory);\par
\par
// assign categories which this \lang1033\f5 asset\lang1049\f6  belongs to\par
newAsset.setCategories(Arrays.asList(ejb3Category));\par
\par
newAsset.setTechnologies(Arrays.asList(\par
    java15Tech\lang1033\f5 n\lang1049\f6 ology,\par
    informixTechnology\par
));\par
remote.createAsset(newAsset);\b\par
\f0\fs20\par
Create a new version\par
\b0\f6\fs16 // retrieve \lang1033\f5 asset\lang1049\f6  \lang1033\f5 with\lang1049\f6  current version\par
AssetDTO asset = remote.getAssetById(\lang1033\f5 assetId\lang1049\f6 , true);\par
asset.setName("Catalog Service"); // update \lang1033\f5 asset\lang1049\f6  name\par
asset.setVersionText("1.1"); // sent new text version\par
asset.setVersionId(null); // reset version\rquote s ID\par
asset.setProductionDate(parseDate("2008/01/10")); // set new production date\par
remote.createVersion(asset);\b\par
\b0\f0\fs20 Updating an asset works in a similar way, except that it doesn't create a new version, but just updates the version referred by DTO.\b\par
\par
Find assets\par
\b0\f6\fs16 List<AssetDTO> assets = remote.findAssets(\par
    new SearchCriteria(null, null, null, "catalog", null), true);\b\par
\b0\f0\fs20 Suppose we have in catalog Catalog Service and Catalog Entities \lang1033\f3 assets\lang1049\f0 . The list will contain them both.\b\par
\par
\pard\keepn\nowidctlpar\s1\sb120\sa60\sl240\slmult0\tx360\lang1033\f1\fs24 5.\tab\lang1049\f0 Future Enhancements\par
\pard\nowidctlpar\li720\sa120\sl238\slmult0\b0\fs20 More services can be provided to meet additional needs.\b\par
\par
\pard\nowidctlpar\b0\f2\fs24\par
}
 