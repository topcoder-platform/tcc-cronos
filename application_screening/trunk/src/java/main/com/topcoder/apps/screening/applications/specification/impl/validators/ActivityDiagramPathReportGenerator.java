/*
 * Copyright (C) 2006 TopCoder Inc., All Rights Reserved.
 *
 * ActivityDiagramPathReportGenerator.java
 */
package com.topcoder.apps.screening.applications.specification.impl.validators;

import com.topcoder.apps.screening.applications.specification.ValidationOutput;
import com.topcoder.apps.screening.applications.specification.Submission;
import com.topcoder.apps.screening.applications.specification.ValidationOutputType;
import com.topcoder.util.xmi.parser.data.UMLActivityDiagram;
import com.topcoder.util.xmi.parser.data.UMLState;
import com.topcoder.util.xmi.parser.data.UMLTransition;
import com.topcoder.util.xmi.parser.data.UMLElement;

import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Iterator;
import java.util.Map;

/**
 * <p>
 * This class doesn’t perform any validation of the activity diagram. Instead it generates a report of all unique
 * paths throughout the diagram. Each path will be assigned a unique path number.
 * </p>
 *
 * <p>
 * The path will be  represented by a sequence of activity diagram nodes and transitions. Guard names for
 * transitions will be used to identify edges. If some transition doesn’t have the guard name, the state name
 * only will be used to identify the transition.
 * </p>
 *
 * <p>
 * The activity graph for an activity diagram may contain loops. To resolve such situation all unique paths
 * will ensure that no activity graph state will be traversed more than twice (two visits i.e. a single loop
 * traversal is allowed).
 * </p>
 *
 * <p>
 * Each ValidationOutput item generated by this class will have the REPORT type. Each such item
 * will correspond to a single unique path from some initial to some final state. The details string
 * will contain an XML representation of the path in the following format:
 * <pre>
 * &lt;path number=&quot;${pathNumber}&quot;&gt;
 * &lt;node&gt;{initial node name} - ${guard transition name}&lt;/node&gt;
 * &lt;node&gt;${next node name} - ${guard transition name}&lt;/node&gt;
 * ...
 * &lt;path&gt;
 * </pre>
 * </p>
 *
 * <p>
 * Note that the guard transition name is optional (it will be absent if the guard is empty).
 * The final node is not included to the path.
 * Number of returned ValidationOutput items will be equal to the number of unique paths in the
 * diagram.
 * </p>
 *
 * <p>
 * Thread-Safety: this class is stateless and therefore thread-safe.
 * </p>
 *
 * @author nicka81, TCSDEVELOPER
 * @version 1.0
 */
public class ActivityDiagramPathReportGenerator extends ActivityDiagramValidator {

    /**'Path' node name. */
    private static final String PATH = "Path";

    /**'Node' node name.*/
    private static final String NODE = "Node";

    /**'number' attribute of 'Path' node.*/
    private static final String PATH_NUMBER = "number";

    /**Open bracket.*/
    private static final String OPEN_BRACKET = "<";

    /**Close bracket.*/
    private static final String CLOSE_BRACKET = ">";

    /**Open bracket with slash.*/
    private static final String CLOSE_NODE = "</";

    /**New line symbol.*/
    private static final String NEW_LINE = "\n";

    /**Dash symbol.*/
    private static final String DASH = " - ";

    /**Equality symbol with quot.*/
    private static final String EQUAL = "='";

    /**Quot with close bracket.*/
    private static final String QUOT_WITH_BRACKET = "'>";

    /**
     * <p>
     * Default class constructor.
     * </p>
     */
    public ActivityDiagramPathReportGenerator() {
        // does nothing
    }

    /**
     * <p>
     * Concrete validation method generating an XML report of all unique paths for the activity diagram.
     * The path will be  represented by a sequence of activity diagram nodes and transitions.
     * </p>
     *
     * <p>
     * A single ValidationOutput item will be generated for each path.
     * All paths will be numbered sequentially starting from one.
     * Loops are allowed, but no path can pass through the same state more than twice.
     * The final node is not included to the path.
     * </p>
     *
     * @param activityDiagram the diagram to validate
     * @param submission     the submission containing this diagram
     * @return the array of validation outputs
     * @throws IllegalArgumentException if any parameter is null
     */
    protected ValidationOutput[] validateActivityDiagram(UMLActivityDiagram activityDiagram,
                                                         Submission submission) {
        if (activityDiagram == null) {
            throw new IllegalArgumentException("UseCaseDiagram must not be null.");
        }
        if (submission == null) {
            throw new IllegalArgumentException("Submission must not be null.");
        }

        //if there is no action states in diagram, than empty array will be returned
        if (activityDiagram.getStates().size() == 0) {
            return new ValidationOutput[0];
        }

        //list with outputs
        List retList = new ArrayList();

        //get all initial states
        List initialStates = activityDiagram.getInitialStates();
        // we run DFS for all transitions from the initial state
        for (Iterator iter = initialStates.iterator(); iter.hasNext();) {
            UMLState state = (UMLState) iter.next();

            List transitionsFrom = activityDiagram.getTransitionsFrom(state.getElementId());
            for (Iterator transIter = transitionsFrom.iterator(); transIter.hasNext();) {
                UMLTransition transition = (UMLTransition) transIter.next();

                LinkedList transitions = new LinkedList();
                transitions.add(transition);

                dfs(activityDiagram, transition.getToId(), transitions, retList);
            }
        }

        return (ValidationOutput[]) retList.toArray(new ValidationOutput[retList.size()]);
    }

    /**
     * <p>
     * Performs DFS.
     * </p>
     *
     * <p>
     * Note, that loops are allowed, but they can be added only one time (each state cannot be traversed
     * more than 2 times).
     * </p>
     *
     * @param d activity diagram
     * @param currentNodeId id of the current node
     * @param transitions list with transitions that treats as next path
     * @param retList list where next output (path) will be added
     */
    private void dfs(UMLActivityDiagram d, String currentNodeId, LinkedList transitions, List retList) {
        // check if we visited the final state
        // the developer is encouraged to optimize
        List finalStates = d.getFinalStates();
        for (Iterator iter = finalStates.iterator(); iter.hasNext();) {
            UMLState state = (UMLState) iter.next();
            if (state.getElementId().equals(currentNodeId)) {
                // the current state is final
                // add one more path record

                retList.add(new ValidationOutput(ValidationOutputType.REPORT, d,
                        buildPathReport(d, retList.size() + 1, transitions)));
                return;
            }
        }

        // this is not the final state, so we should try all transitions
        List trans = d.getTransitionsFrom(currentNodeId);
        for (Iterator transIter = trans.iterator(); transIter.hasNext();) {
            UMLTransition t = (UMLTransition) transIter.next();
            int cntVisited = 0;

            //each loop may be added only one time, so each state cannot be traversed more
            //than 2 times
            for (Iterator prevIter = transitions.iterator(); prevIter.hasNext();) {
                UMLTransition prev = (UMLTransition) prevIter.next();
                if (prev.getFromId().equals(t.getToId())) {
                    cntVisited++;
                }

                if (prev.getToId().equals(t.getToId())) {
                    cntVisited++;
                }
            }

            // don’t visit the same state third time
            if (cntVisited <= 2) {
                // the transition is new, try it
                transitions.addLast(t);
                dfs(d, t.getToId(), transitions, retList);
                transitions.removeLast();
            }
        }
    }

    /**
     * <p>
     * Builds the details string (XML) for the given list of transitions.
     * </p>
     *
     * @param d activity diagram
     * @param pathNumber number of this path
     * @param transitions list with transitions
     * @return xml representation of next path
     */
    private String buildPathReport(UMLActivityDiagram d, int pathNumber, List transitions) {
        //result buffer
        StringBuffer buf = new StringBuffer();
        buf.append(OPEN_BRACKET).append(PATH).append(" ").append(PATH_NUMBER).append(EQUAL).
                append(pathNumber).append(QUOT_WITH_BRACKET).append(NEW_LINE);

        //map with diagram's elements is used for getting states' names
        Map diagramsElements = d.getElementsMap();

        //process each element
        for (Iterator iter = transitions.iterator(); iter.hasNext();) {
            UMLTransition t = (UMLTransition) iter.next();
            buf.append(OPEN_BRACKET).append(NODE).append(CLOSE_BRACKET);

            //append state's name
            buf.append(getElementName(diagramsElements, t.getFromId()));

            //if transition's guard condition is specified, than we shoul add it
            if (t.getGuardCondition() != null && t.getGuardCondition().length() != 0) {
                buf.append(DASH);
                buf.append(t.getGuardCondition());
            }
            buf.append(CLOSE_NODE).append(NODE).append(CLOSE_BRACKET).append(NEW_LINE);
        }
        buf.append(CLOSE_NODE).append(PATH).append(CLOSE_BRACKET);

        return buf.toString();
    }

    /**
     * <p>
     * This method returns element's name, or empty string if element does not exist.
     * </p>
     *
     * @param elements map with elements
     * @param id ID of element, which name we should return
     * @return element's name
     */
    private String getElementName(Map elements, String id) {
        UMLElement element = (UMLElement) elements.get(id);
        return (element == null) ? "" : element.getElementName();
    }
}