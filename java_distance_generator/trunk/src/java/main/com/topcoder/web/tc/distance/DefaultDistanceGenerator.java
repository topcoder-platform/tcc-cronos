/*
 * Copyright (C) 2008 TopCoder Inc., All Rights Reserved.
 */
package com.topcoder.web.tc.distance;

import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import com.topcoder.util.errorhandling.ExceptionData;
import com.topcoder.util.errorhandling.ExceptionUtils;
import com.topcoder.web.tc.distance.data.Member;
import com.topcoder.web.tc.distance.data.MemberDataAccess;
import com.topcoder.web.tc.distance.data.MemberDataAccessException;

/**
 * <p>
 * This class represents the default distance generator for the component. This generator will calculate the
 * distance to all related members and return an XML string that represents the results.
 * </p>
 * <p>
 * This class will be created by the application and called to generate distances for a specified coder, distance
 * type(s) and competition type(s). This class will work with the MemberDataAccess to retrieve member related
 * information and then call the distance calculators to calculate the various distances for each member - the
 * resulting distances are then weighed by the DistanceWeighting before being written to XML.
 * </p>
 * <p>
 * Thread-safety: this class is thread safe because its state is immutable and the state itself is thread safe.
 * </p>
 *
 * @author Pops, romanoTC
 * @version 1.0
 */
public class DefaultDistanceGenerator implements DistanceGenerator {
    /**
     * Constant representing the namespace of the XML.
     */
    private static final String XML_NAMESPACE = "http://www.topcoder.com/Distance";

    /**
     * Constant representing the &lt;Distance&gt; element in the XML string output generated by this class. This is
     * the root element of the XML.
     */
    private static final String ROOT_ELEMENT = "Distance";

    /**
     * Constant representing the &lt;map&gt; element in the XML string output generated by this class.
     */
    private static final String MAP_ELEMENT = "map";


    /**
     * Constant representing the &lt;coder&gt; element in the XML string output generated by this class.
     */
    private static final String CODER_ELEMENT = "coder";

    /**
     * Constant representing the &lt;coder_id&gt; element in the XML string output generated by this class.
     */
    private static final String CODER_ID_ELEMENT = "coder_id";

    /**
     * Constant representing the &lt;handle&gt; element in the XML string output generated by this class.
     */
    private static final String HANDLE_ELEMENT = "handle";

    /**
     * Constant representing the &lt;rating&gt; element in the XML string output generated by this class.
     */
    private static final String RATING_ELEMENT = "rating";

    /**
     * Constant representing the &lt;image&gt; element in the XML string output generated by this class.
     */
    private static final String IMAGE_ELEMENT = "image";

    /**
     * Constant representing the &lt;overlap&gt; element in the XML string output generated by this class.
     */
    private static final String OVERLAP_ELEMENT = "overlap";

    /**
     * Constant representing the &lt;country&gt; element in the XML string output generated by this class.
     */
    private static final String COUNTRY_ELEMENT = "country";

    /**
     * Constant representing the &lt;distance&gt; element in the XML string output generated by this class.
     */
    private static final String DISTANCE_ELEMENT = "distance";

    /**
     * <p>
     * This variable represents the member data access used to retrieve member information. This value is set in
     * the constructor, is immutable and will never be null. This variable is only referenced in the
     * generateDistance method.
     * </p>
     */
    private final MemberDataAccess memberDataAccess;

    /**
     * <p>
     * This variable represents the distance weighting used to weight the distance. This value is set in the
     * constructor, is immutable and will never be null. This variable is only referenced in the generateDistance
     * method.
     * </p>
     */
    private final DistanceWeighting distanceWeighting;

    /**
     * <p>
     * This variable represents the distance weighting used to weight the distance. This value is set initially to
     * a new HashMa&lt;DistanceType, DistanceCalculator&gt;(), is immutable (both the reference and contents) and
     * will never be null nor an empty set. The key will be a DistanceType and the value will be the
     * DistanceCalculator associated with this type. Neither the key nor the value will be null. This variable is
     * only referenced in the generateDistance method.
     * </p>
     */
    private final Map<DistanceType, DistanceCalculator> distanceCalculators =
        new HashMap<DistanceType, DistanceCalculator>();

    /**
     * <p>
     * Constructs the default distance generator from the given arguments.
     * </p>
     *
     * @param distanceCalculators
     *            A non-null, non-empty list of DistanceCalculators to use (containing no null elements)
     * @param distanceWeighting
     *            A non-null distanceWeighting to use
     * @param memberDataAccess
     *            A non-null memberDataAccess to use
     * @throws IllegalArgumentException
     *             if any argument is null; if distanceCalculators is empty or contains a null element.
     */
    public DefaultDistanceGenerator(MemberDataAccess memberDataAccess, DistanceWeighting distanceWeighting,
            List<DistanceCalculator> distanceCalculators) {

        ExceptionUtils.checkNull(memberDataAccess, null, null, "The [memberDataAccess] argument cannot be null.");
        ExceptionUtils
                .checkNull(distanceWeighting, null, null, "The [distanceWeighting] argument cannot be null.");
        ExceptionUtils.checkNull(distanceCalculators, null, null,
                "The [distanceCalculators] argument cannot be null.");

        if (distanceCalculators.isEmpty()) {
            throw new IllegalArgumentException("The [distanceCalculators] argument cannot be empty.");
        }

        for (DistanceCalculator calculator : distanceCalculators) {
            ExceptionUtils.checkNull(calculator, null, null,
                    "The [distanceCalculators] argument cannot have null elements.");

        }

        this.memberDataAccess = memberDataAccess;
        this.distanceWeighting = distanceWeighting;

        for (DistanceCalculator distanceCalculator : distanceCalculators) {
            this.distanceCalculators.put(distanceCalculator.getDistanceType(), distanceCalculator);
        }
    }

    /**
     * <p>
     * This method will generate the distance from a coder to their related members based on the specified
     * DistanceType(s) and CompetitionType(s). The results will be returned as an XML document.
     * </p>
     *
     * @param coderId
     *            A &gt; 0 coder identifier to find distances from.
     * @param distanceTypes
     *            A non-null enum set containing the distance types to check.
     * @param compTypes
     *            A non-null enum set containing the competitions to check.
     * @return A non-null, non-empty string containing the results.
     * @throws IllegalArgumentException
     *             if any argument is null; coder_id is less than 0.
     * @throws DistanceGeneratorException
     *             if an exception occurs while processing.
     */
    public String generateDistance(long coderId, EnumSet<DistanceType> distanceTypes,
            EnumSet<CompetitionType> compTypes) {

        if (coderId < 0) {
            throw new IllegalArgumentException("The [coderId] argument cannot be negative.");
        }

        ExceptionUtils.checkNull(distanceTypes, null, null, "The [distanceTypes] argument cannot be null.");
        ExceptionUtils.checkNull(compTypes, null, null, "The [compTypes] argument cannot be null.");

        // get our member
        Member coder;
        try {
            coder = memberDataAccess.getMember(coderId);

        } catch (MemberDataAccessException ex) {

            throw createDistanceGeneratorException("An error occured while retrieving member using coder_id: "
                + coderId, ex, new String[] {"coderId", "distanceTypes", "compTypes"}, new Object[] {coderId,
                    distanceTypes, compTypes});
        }

        // get the related members
        List<Member> members;
        try {
            members = memberDataAccess.getRelatedMembers(coderId, compTypes);

        } catch (MemberDataAccessException ex) {

            throw createDistanceGeneratorException("An error occured while retrieving related member using coder_id: "
                + coderId, ex, new String[] {"coderId", "distanceTypes", "compTypes", "coder [local]"}, new Object[] {
                    coderId, distanceTypes, compTypes, coder});
        }

        Map<DistanceType, List<Double>> distanceMap = new HashMap<DistanceType, List<Double>>();

        // Calculate the distances for every distanceType
        for (DistanceType distanceType : distanceTypes) {

            // Get the distance calculator for the distance type,
            // any DistanceCalculatorException will pass through to the caller.
            DistanceCalculator calculator = distanceCalculators.get(distanceType);
            List<Double> distances;

            if ((calculator != null) && (compTypes.size() > 0)) {
                distances = calculator.getDistance(coder, members, compTypes);
            } else {
                distances = new ArrayList<Double>(members.size());
                Collections.fill(distances, new Double(-1.0));
            }

            distanceMap.put(distanceType, distances);
        }

        List<Double> memberResults = new ArrayList<Double>();

        for (int idx = 0; idx < members.size(); ++idx) {
            Map<DistanceType, Double> memberMap = new HashMap<DistanceType, Double>();

            for (Map.Entry<DistanceType, List<Double>> distances : distanceMap.entrySet()) {
                DistanceType distanceType = distances.getKey();
                double distanceValue = distances.getValue().get(idx);

                memberMap.put(distanceType, distanceValue);
            }

            double result = distanceWeighting.weightDistance(memberMap);
            memberResults.add(result);
        }

        return writeResult(coder, members, memberResults);
    }

    /**
     * <p>
     * This method will write out the result in XML form to a String. The result will contain the from Member's
     * information as well as the distances to all members.
     * </p>
     * <p>
     * A sample output: <br>
     *
     * <pre>
     * &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
     *     &lt;Distance xmlns=&quot;http://www.topcoder.com/Distance&quot;&gt;
     *     &lt;map&gt;
     *         &lt;coder&gt;
     *             &lt;coder_id&gt;100&lt;/coder_id&gt;
     *             &lt;handle&gt;handle1&lt;/handle&gt;
     *             &lt;rating&gt;100&lt;/rating&gt;
     *             &lt;image&gt;image1&lt;/image&gt;
     *             &lt;overlap&gt;0&lt;/overlap&gt;
     *             &lt;country&gt;USA&lt;/country&gt;
     *             &lt;distance&gt;0.0&lt;/distance&gt;
     *             &lt;/coder&gt;
     *         &lt;coder&gt;
     *             &lt;coder_id&gt;200&lt;/coder_id&gt;
     *             &lt;handle&gt;handle2&lt;/handle&gt;
     *             &lt;rating&gt;200&lt;/rating&gt;
     *             &lt;image&gt;image2&lt;/image&gt;
     *             &lt;overlap&gt;0&lt;/overlap&gt;
     *             &lt;country&gt;Russia&lt;/country&gt;
     *             &lt;distance&gt;0.785&lt;/distance&gt;
     *         &lt;/coder&gt;
     *     &lt;/map&gt;
     * &lt;/Distance&gt;
     * </pre>
     *
     * </p>
     *
     * @param fromMember
     *            A non-null from member
     * @param memberResults
     *            A non-null, non-empty list of members results
     * @param members
     *            A non-null, non-empty list of members to query
     * @return an String representing the XML encoding of the member and its relationships.
     * @throws IllegalArgumentException
     *             if fromMember is null; if either list is null, empty or contains a null element; if both lists
     *             do not have the same size.
     * @throws DistanceGeneratorException
     *             if an exception occurs during processing
     */
    protected String writeResult(Member fromMember, List<Member> members, List<Double> memberResults) {
        ExceptionUtils.checkNull(fromMember, null, null, "The [fromMember] argument cannot be null.");
        Helper.checkCollection(members, "members", false);
        Helper.checkCollection(memberResults, "memberResults", false);

        if (memberResults.size() != members.size()) {
            throw new IllegalArgumentException(
                    "The [members] and [memberResults] arguments must have the same size.");
        }

        // These objects are used during exception handling
        final String[] argumentNames = new String[] {"fromMember", "members", "memberResults"};
        final Object[] arguments = new Object[] {fromMember, members, memberResults};

        // Create the root document
        Document document;
        try {
            document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();

        } catch (FactoryConfigurationError ex) {

            throw createDistanceGeneratorException("An error occured while creating document factory", ex,
                    argumentNames, arguments);

        } catch (ParserConfigurationException ex) {
            throw createDistanceGeneratorException("An error occured while creating a new XML document", ex,
                    argumentNames, arguments);
        }

        try {
            // Create the root element - Any DOMException will be wrapped
            Element rootElement = document.createElementNS(XML_NAMESPACE, ROOT_ELEMENT);

            // Append the root element
            document.appendChild(rootElement);

            // Create a "map" element
            Element mapElement = document.createElement(MAP_ELEMENT);

            // Append the mapElement to the root element
            rootElement.appendChild(mapElement);

            // Append the from member to the map element
            mapElement.appendChild(getMemberElement(document, fromMember, 0));

            for (int idx = 0; idx < members.size(); ++idx) {
                double distance = memberResults.get(idx);

                // if distance is >= append the member element to the map element
                if (distance >= 0.0) {
                    mapElement.appendChild(getMemberElement(document, members.get(idx), distance));
                }
            }
        } catch (DOMException ex) {

            throw createDistanceGeneratorException("An error occured while handling XML elements", ex, new String[] {
                "fromMember", "members", "memberResults"}, new Object[] {fromMember, members, memberResults});
        }

        // Create objects to convert from XML document to String
        try {
            return convertDocumentToString(document);

        } catch (TransformerConfigurationException ex) {
            throw createDistanceGeneratorException("An error occured while creating a new Transformer", ex,
                argumentNames, arguments);

        } catch (TransformerFactoryConfigurationError ex) {

            throw createDistanceGeneratorException("An error occured while creating a new TransformerFactory", ex,
                argumentNames, arguments);

        } catch (TransformerException ex) {
            throw createDistanceGeneratorException("An error occured while creating a new TransformerFactory", ex,
                argumentNames, arguments);
        }
    }

    /**
     * Converts the given Document to a String format using a StreamResult and a Transformer.
     *
     * @param document the original XML document to be converted.
     * @return the converted String
     * @throws TransformerConfigurationException if any error occurs while acquiring a new transformer.
     * @throws TransformerException if any error occurs during XML conversion.
     * @throws TransformerFactoryConfigurationError if any error occurs during XML conversion.
     */
    private String convertDocumentToString(Document document) throws TransformerException {
        // Create objects to convert from XML document to String
        DOMSource source = new DOMSource(document);
        StringWriter sw = new StringWriter();

        StreamResult result = new StreamResult(sw);
        Transformer transformer;

        transformer = TransformerFactory.newInstance().newTransformer();

        // Writes the XML document inside the StringWriter using the created Transformer so we can finally
        // convert
        // it to a String.
        transformer.transform(source, result);

        return sw.toString();
    }

    /**
     * <p>
     * Returns the element represented by the member.
     * </p>
     *
     * @param document a non-null document used to create new elements.
     * @param member A non-null member
     * @param distance A distance value
     * @return A non-null Element representing the member
     * @throws DOMException if any error occurs while handling XML elements.
     */
    private Element getMemberElement(Document document, Member member, double distance) {
        Element coderElement = document.createElement(CODER_ELEMENT);

        appendElement(document, coderElement, CODER_ID_ELEMENT, Long.toString(member.getId()));
        appendElement(document, coderElement, HANDLE_ELEMENT, member.getHandle());
        appendElement(document, coderElement, RATING_ELEMENT, Integer.toString(member.getMaxRating()));
        appendElement(document, coderElement, IMAGE_ELEMENT, member.getImage());
        appendElement(document, coderElement, OVERLAP_ELEMENT, Integer.toString(member.getMatchOverlap()));
        appendElement(document, coderElement, COUNTRY_ELEMENT, member.getCountry());
        appendElement(document, coderElement, DISTANCE_ELEMENT, Double.toString(distance));

        return coderElement;
    }

    /**
     * Append a new Element to the given root element. The element will be named after tagName and contain a value.
     *
     * @param document
     *            the document used to create the new element.
     * @param root
     *            the root element to which append the new created element.
     * @param tagName
     *            the element's name.
     * @param value
     *            the element's value.
     * @throws DOMException
     *             if any error occurs while handling XML elements.
     */
    private void appendElement(Document document, Element root, String tagName, String value) {
        Element childElement = document.createElement(tagName);
        childElement.setTextContent(value);
        root.appendChild(childElement);
    }

    /**
     * Create a DistanceGeneratorException with an ExceptionData containing the given information mapped by the
     * given keys.
     *
     * @param message
     *            the exception message.
     * @param cause
     *            the exception inner cause.
     * @param keys
     *            the ExceptionData information keys.
     * @param information
     *            the ExceptionData keys.
     * @return a DistanceGeneratorException with an ExceptionData containing the given information mapped by the
     *         given keys.
     */
    private DistanceGeneratorException createDistanceGeneratorException(String message, Throwable cause,
            String[] keys, Object[] information) {

        ExceptionData data = new ExceptionData();
        for (int i = 0; i < keys.length; ++i) {
            data.setInformation(keys[i], information[i]);
        }

        data.setInformation("memberDataAccess [instance]", memberDataAccess);
        data.setInformation("distanceWeighting [instance]", distanceWeighting);
        data.setInformation("distanceCalculators [instance]", distanceCalculators);

        return new DistanceGeneratorException(message, cause, data);
    }

}
