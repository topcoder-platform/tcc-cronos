{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe1033\deftab420{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fprq2\fcharset0 Times New Roman;}{\f2\fnil\fprq2\fcharset2 Wingdings;}{\f3\fnil\fprq2\fcharset134 SimSun;}{\f4\fmodern\fprq1\fcharset0 Courier New;}{\f5\fnil Courier New;}{\f6\froman\fprq2\fcharset2 Symbol;}{\f7\froman\fprq2\fcharset0 Symbol;}}
{\colortbl ;\red0\green0\blue255;\red255\green0\blue0;\red0\green0\blue0;\red212\green212\blue212;\red255\green255\blue0;}
{\stylesheet{ Normal;}{\s1 heading 1;}{\s2 heading 2;}{\s3 heading 3;}}
{\*\generator Msftedit 5.41.15.1507;}\viewkind4\uc1\pard\keepn\nowidctlpar\s1\sb120\sa60\sl240\slmult0\tx720\ul\b\f0\fs28 Time Tracker Contact 3.2 Component Specification\par
\pard\nowidctlpar\li720\sa120\ulnone\b0\f1\fs20\par
Note that all v3.2 updates are in \cf1 blue\cf0  and all additions are in \cf2 red\cf0 .\par
\pard\keepn\nowidctlpar\s1\sb120\sa60\sl240\slmult0\tx360\b\f0\fs24 1.\tab Design\par
\pard\nowidctlpar\li720\b0\fs20 The Time Tracker Contact custom component is part of the Time Tracker application.  It provides an abstraction of contacts and addresses.  Contacts and Addresses exist in Time Tracker as a many to any relationship to many other entities.  This component handles the persistence and other business logic required by the application.\par
\cf3\f1\par
\cf0\f0 This design provides ContactManager and AddressManager which can be used to add, update and retrieve Contacts and Addresses.\par
\par
The Contacts/Addresses can be searched with filter. Predefined filters can be created by the filter factory. The user can also created custom filters by the Filters provide by Search Builder component.\par
\par
The action which will modify the database can be audited according to user\rquote s setting. And the audit will be rollback if the transaction is failed.\par
\par
And the data source is pluggable, new data source can be easily added. \par
\par
\cf2 New features in version 3.2:\par
\pard\fi-360\li1080\tx1080\f1 -\tab\f0 Introduces a session bean to facilitate transactional control for each of Contact and Address. This was a major issue with the 3.1 version. As a result, the DAO implementation documentation as well as the relevant SDs is modified to remove all manual transaction control.\par
\pard\fi-360\li1080\f1 -\tab\f0 The v3.1 ContactManager and AddressManager will become delegates to these beans. As such, the managers will be split into an interface with this name, and a delegate implementation for the EJB integration.\par
\f1 -\tab\f0 Only local access to the bean is needed. \par
\f1 -\tab\f0 Transactional control uses the \ldblquote required\rdblquote  setting to guarantee that any action is always under such control.\par
\pard\nowidctlpar\li720\cf0\par
\cf2 DESIGN CONSIDERATIONS:\par
\cf0\par
\pard\nowidctlpar\li720\sa120\cf2\ul EJBs and ConfigManager:\par
\pard\nowidctlpar\li720\ulnone The EJB specification stipulates that File I/O is not allowed during the execution of the bean. At first glance this might mean that the use of the Config Manager, and by extension Object Factory, DB Connection Factory, and ID generator, could not be allowed because it performs property retrieval and storing using files. However, the restriction is only placed on the bean\rquote s lifetime, not the ConfigManager\rquote s. Therefore, as long as the Config Manager does not perform I/O itself during the execution of the bean, or to be more accurately, that the thread performing a bean operation does not cause the ConfigManager to perform I/O in the course of the bean\rquote s execution, the use of Config Manager to hold an in-memory library of properties is acceptable. Therefore, this design makes extensive use of Config Manager, Object Factory, DB Connection Factory, and ID generator, again, with the stipulation that the Config Manager implementation does not perform I/O when this component is retrieving properties. The current default implementation of the Config Manager holds all loaded properties in a map, so all property reading is done in-memory.\par
\par
In general, and aside to the central issue here, the purpose behind the EJB specification stipulation against I/O during the business operation of the bean exists to accommodate portability. In practice, since portability is not always a reason behind the choice to use EJBs, many containers allow direct I/O in the bean. In fact, since the main purpose of the use of EJBs in this application is to enforce transactional control, I/O may be allowed as long as the access can be transitionally controlled, something that is a challenge in itself.\par
\par
\pard\nowidctlpar\li720\sa120\ul Serialization and Filter:\par
\ulnone The Filter hierarchy in Search Builder is currently not serializable, which means it currently cannot be used. The PM is currently researching solutions to this.\par
\par
\ul JNDI and DBConnectionFactory:\par
\ulnone The TxDataSource required for this component can still be obtained as a javax.sql.DataSource. As such, the JNDIConnectionProvider available in the DBConnection Factory component can still perform connection creation services for this design. As such, it is kept unaltered in the DAO implementations.\par
\pard\nowidctlpar\li720\cf0\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\b 1.1\tab\cf1 Design Patterns\cf0  \par
\pard\nowidctlpar\fi-420\li1140\tx1140\f2\fs16 l\tab\b0\f0\fs20 Data Access Object Pattern is used by InformixContactDAO & InformixAddressDAO.\f1\fs24\par
\b\f2\fs16 l\tab\b0\f0\fs20 Strategy Pattern is used to allow plugging different types of data source.\f1\fs24\par
\pard\nowidctlpar\fi-360\li1080\tx1080\b\f2\fs16 l\tab\b0\f0\fs20 Factory Pattern is used to create different filters by ContactFilterFactory & AddressFilterFactory.\par
\pard\nowidctlpar\fi-360\li1080\cf2\b\f2\fs16 l\tab\b0\f0\fs20 Business Delegate Pattern is used by manager implementation so the user is decoupled from the intricacies of obtaining and calling the session EJBs.\par
\pard\nowidctlpar\fi-420\li1140\cf0\b\f2\fs16 l\tab\b0\f0\fs20 Facade Pattern is used by ContactManager & Address\lang2052\f3 Manager\lang1033\f0 .\par
\f1\fs24\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\b\f0\fs20 1.2\tab\cf1 Industry Standards\cf0  \par
\pard\nowidctlpar\li720\b0 JavaBean\par
SQL\par
\cf2 JDBC\par
EJB 2.1\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\cf0\b 1.3\tab\cf1 Required Algorithms\cf0\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\b0 The algorithms of Contact and Address are almost the same, therefore only Contact algorithms are listed below. \par
\pard\nowidctlpar\fs24\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\cf2\fs20 Note: For v3.2, all rollbacks occur in the EJB. Therefore, even the audit manager is not called programmatically to rollback the created audit.\par
\pard\nowidctlpar\cf0\fs24\par
\pard\keepn\nowidctlpar\s3\fi-840\li840\sb120\sa60\sl240\slmult0\tx0\tx840\i\fs20 1.3.1\tab Alias of column name\par
\pard\nowidctlpar\li709\i0 The column names used in filter factories are aliases. The SearchBundle will convert the aliases to the corresponding actual names defined in the SearchBundle configuration files.\par
Every alias used by the filter factories should be defined in the \ldblquote alias\rdblquote  property of the SearchBundle configuration files.\par
\pard\keepn\nowidctlpar\s3\fi-840\li840\sb120\sa60\sl240\slmult0\tx0\tx840\cf2\i 1.3.2\tab Call ContactBean ejbCreate\f1\par
\pard\nowidctlpar\fi-360\li1080\tx1080\i0\f0 1.\tab Obtain environmental values from JNDI for the namespace and DAO key.\par
\pard\nowidctlpar\fi-360\li1080 2.\tab Create the ObjectFactory with a new ConfigManagerSpecificationFactory created with the retrieved namespace\par
3.\tab Create dao by the ObjectFactory with the retrieved key ContactDAOKey\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\cf0\i 1.3.3\tab Construct InformixContactDAO with given namespace\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0 1.\tab Get the configManager by ConfigManager.getInstance()\par
\pard\nowidctlpar\fi-420\li1140 2.\tab Get the connectionFactoryNamespace from the configManager with namespace and key as "connection_factory_namespace"\par
3.\tab Create the connectionFactory by new DBConnectionFactoryImpl(connection_factory_namespace)\par
4.\tab Get the connectionName from the configManager with namespace and key as "connection_name"\par
5.\tab Get the idGeneratorName from the configManager with namespace and key as "idgenerator_name"\par
6.\tab Get contactIDGenerator by IDGeneratorFactory.getIDGenerator(idGeneratorName)\par
7.\tab Get the searchBundleName from the configManager with namespace and key as "search_bundle_name"\par
8.\tab Get the searchBundleNamespace from the configManager with namespace and key as "search_bundle_namespace"\par
9.\tab Create search bundle manager with searchBundleNamespace\par
10.\tab Get searchBundle by manager.getSearchBundle(search_bundle_name)\par
11.\tab If auditManager is null, get the auditManagerNamespace from the configManager with namespace and key as "audit_manager_namespace". Create the ObjectFactory with a new ConfigManagerSpecificationFactory created with the auditManagerNamespace. Create auditManager by the ObjectFactory with the key as "AuditManager"\par
\pard\nowidctlpar\li720\f1\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\i\f0 1.3.4\f1\tab\f0 Add contact\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0\f4 1.\tab Throw InvalidPropertyException if any property of the contact is null.\par
\pard\nowidctlpar\fi-420\li1140 2.\tab Set the ID of the contact by idGenerator.getNextID()\par
3.\tab Set the creation and modification date to current date.\par
4.\tab If doAudit is true, create an auditHeader with the info of this contact and create it by AuditManager\par
5.\tab Get a connection by createConnection, and create a prepared statement to add the contact to the contact table.\par
6.\tab Set all the parameters of the statement according to all the properties of contact and execute the statement.\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\i\f0 1.3.5\f1\tab\f0 Add contacts\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0 1.\tab For each contact ...\par
\pard\nowidctlpar\fi-420\li1560\tx1560 a)\tab Throw InvalidPropertyException if any property of the contact is null.\par
\pard\nowidctlpar\fi-420\li1560 b)\tab Set the ID of the contact by contactIDGenerator.getNextID()\par
c)\tab If doAudit is true, create an auditHeader with the info of this contact and create it by AuditManager\par
d)\tab Add the id of the header to the auditId which is created by new long[contacts.length]\par
\pard\nowidctlpar\li720 ... end each\par
\pard\nowidctlpar\fi-420\li1140\tx1140 2.\tab Get a connection by createConnection and create a prepared statement to add the contact to the contact table.\par
\pard\nowidctlpar\fi-420\li1140 3.\tab For each contact, set all the parameters of the statement according to all the properties of contact and addBatch\par
4.\tab Execute the batch, and get the returned int[]\par
5.\tab If BatchUpdateException is thrown\par
\pard\nowidctlpar\fi-420\li1560\tx1560 a)\tab Create a boolean[], set boolean[i] to int[i]!=EXECUTE_FAILED, create BatchOperationException with the boolean array.\par
\pard\nowidctlpar\fi-420\li1560 b)\tab Throw the BatchOperationException.\par
\pard\nowidctlpar\li720\f1\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\i\f0 1.3.6\f1\tab\f0 Update contact\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0 1.\tab Throw InvalidPropertyException if the id of the contact <=0, or any property of the contact is null. \par
\pard\nowidctlpar\fi-420\li1140 2.\tab If the bean is not changed(contact.isChanged() is false), simply return. \par
3.\tab Set the modification date to current date. \par
4.\tab If doAudit is true, get the contact with the id by retrieveContact. Create an auditHeader with the different and create it by AuditManager \par
5.\tab Get a connection by createConnection, and create a prepared statement to update the contact. \par
6.\tab Set all the parameters of the statement according to all the properties of contact and execute the statement. \par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\i 1.3.7\f1\tab\f0 Update contacts\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0 1.\tab Get all the ids of contacts\par
\pard\nowidctlpar\fi-420\li1140 2.\tab Get the orgContacts by retrieveContacts(ids)\par
3.\tab For each contact ...\f1\par
\pard\nowidctlpar\fi-420\li1560\tx1560\f0 a)\tab Throw InvalidPropertyException if the id of the contact <=0, or any property of the contact is null.\f1\par
\pard\nowidctlpar\fi-420\li1560\f0 b)\tab Set the modification date to current date.\par
c)\tab If doAudit is true, create an auditHeader with the difference between orgContact and contact, and create it by AuditManager\par
d)\tab Add the id of the header to the auditId which is created by new long[contacts.length]\par
\pard\nowidctlpar\fi-420\li1140\tx1140 4.\tab ... end each\par
\pard\nowidctlpar\fi-420\li1140 5.\tab Get a connection by createConnection and create a prepared statement to update the contact in the contact table.\par
6.\tab For each contact, set all the parameters of the statement according to all the properties of contact and addBatch\par
7.\tab Execute the batch, and get the returned int[]\par
8.\tab If the BatchUpdateOperation is thrown\par
\pard\nowidctlpar\fi-420\li1560\tx1560 a)\tab Create a boolean[], set boolean[i] to int[i]!=EXECUTE_FAILED\par
\pard\nowidctlpar\fi-420\li1560 b)\tab Throw the BatchOperationException.\f1\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\i\f0 1.3.8\f1\tab\f0 Remove contact\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0 1.\tab If doAudit is true, create an auditHeader with the info of this contact and create it by AuditManager\par
\pard\nowidctlpar\fi-420\li1140 2.\tab Get a connection by createConnection, and create a prepared statement to remove the contact from the contact table.\par
3.\tab Set the parameter of the statement to the id of contact and execute it.\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\i 1.3.9\f1\tab\f0 Remove contacts\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0 1.\tab Get the contacts by retrieveContacts(ids)\par
\pard\nowidctlpar\fi-420\li1140 2.\tab For each contact ...\par
\pard\nowidctlpar\fi-420\li1560\tx1560 a)\tab If doAudit is true, create an auditHeader with the info of this contact and create it by AuditManager\par
\pard\nowidctlpar\fi-420\li1560 b)\tab Add the id of the header to the auditId which is created by new long[contacts.length]\par
\pard\nowidctlpar\fi-420\li1140\tx1140 3.\tab ... end each\par
\pard\nowidctlpar\fi-420\li1140 4.\tab Get a connection by createConnection and create a prepared statement to remove the contact with given id from the contact table.\par
5.\tab For each contact, set all the parameter of the statement to id of contact and addBatch\par
6.\tab Execute the batch, and get the returned int[]\par
7.\tab If the BatchUpdateOperation is thrown\par
\pard\nowidctlpar\fi-420\li1560\tx1560 a)\tab Create a boolean[], set boolean[i] to int[i]!=EXECUTE_FAILED, create BatchOperationException with the boolean array.\par
\pard\nowidctlpar\fi-420\li1560 b)\tab Throw the BatchOperationException.\f1\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\i\f0 1.3.10\f1\tab\f0 Retrieve contact\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0 1.\tab Get a connection by createConnection, and create a prepared statement to retieve the contact from the contact table with the contact type from contact_type table.\par
\pard\nowidctlpar\fi-420\li1140 2.\tab Set the id of contact in the statement and execute it.\par
3.\tab If the record is found, create Contact with the ContactType\fs24  \fs20 (the id of the ContactType should equal the contact_id) according this record.\par
4.\tab Else return null\par
5.\tab Close the connection before return\f1\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\i\f0 1.3.11\f1\tab\f0 Retrieve contacts\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0 1.\tab Get a connection by createConnection, and create a prepared statement to retieve the all the contacts with given ids from the contact table with the contact type from contact_type table.\par
\pard\nowidctlpar\fi-420\li1140 2.\tab Execute the statement.\par
3.\tab For each record, create Contact with the ContactType\fs24  \fs20 (the id of the ContactType should equal the contact_id) according this record.\par
4.\tab Close the connection and return an array containing all the Contacts\f1\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\i\f0 1.3.12\f1\tab\f0 Get all contacts\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0 1.\tab Get a connection by createConnection, and create a statement.\par
\pard\nowidctlpar\fi-420\li1140 2.\tab Build sql query to retrieve contacts with given ids from the contact table with the contact type from contact_type table and execute it.\par
3.\tab For each record, create a new Contact and ContactType\fs24  \fs20 (the id of the ContactType should equal the contact_id) according to the record\par
4.\tab Close the connection and return an array containing all the Contacts\par
\par
\cf2 Note that getting all countries and states is very similar (details in the method documentation is provided)\f1\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\cf0\i\f0 1.3.13\f1\tab\f0 search contacts\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0 1.\tab Call searchBundle.search(filter)\par
\pard\nowidctlpar\fi-420\li1140 2.\tab For each record\par
3.\tab Create a new Contact and ContactType\fs24  \fs20 (the id of the ContactType should equal the contact_id) according to the record\par
4.\tab ... end each\par
\pard\nowidctlpar\fi-420\li1140\tx1140 5.\tab Return an array containing all the Contacts\f1\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\i\f0 1.3.14\f1\tab\f0 Associate contact with entity\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0 1.\tab If doAudit is true, create an auditHeader with the info of this association and create it by AuditManager\par
\pard\nowidctlpar\fi-420\li1140 2.\tab Get a connection by createConnection, and create a prepared statement to add the association to the contact_relation table.\par
3.\tab Set all the parameters of the statement according to the contact ID, contact type ID, entity ID and execute the statement.\par
4.\tab Execute the statement.\f1\par
\pard\nowidctlpar\li720\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\i\f0 1.3.15\f1\tab Dea\f0 ssociate contact with entity\par
\pard\nowidctlpar\fi-420\li1140\tx1140\i0 1.\tab If doAudit is true, create an auditHeader with the info of this association and create it by AuditManager\par
\pard\nowidctlpar\fi-420\li1140 2.\tab Get a connection by createConnection, and create a prepared statement to delete the association to the contact_relation table.\par
3.\tab Set all the parameters of the statement according to the contact ID, contact type ID, entity ID and execute the statement.\par
\pard\nowidctlpar\f1\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\b\f0 1.4\tab Component Class Overview\par
\pard\nowidctlpar\li720\cf1 ContactManager\b0 :\par
\pard\nowidctlpar\li1440 This interface defines the contract for the complete management of a contact. It provides single and batch CRUD operations as well as the means to associate or disassociate a contact from an entity. It also provides the ability to audit each operation, if so desired. It has one implementation in this design: ContactManagerLocalDelegate.\par
\pard\nowidctlpar\li720\cf0\b\f1\par
\f0 Contact\b0 :\par
\pard\nowidctlpar\li1440 This class holds the information of a contact. \par
\par
\pard\nowidctlpar\li720\b ContactDAO\b0 :\par
\pard\nowidctlpar\li1440 This interface specifies the contract for implementations of a Contact DAOs. A ContactDAO is responsible for accessing the database. \par
\par
\pard\nowidctlpar\li720\b InformixContactDAO\b0 :\par
\pard\nowidctlpar\li1440 This class is the Informix database implementation of the ContactDAO. It provides general retrieve/update/remove/add functionality to access the database. And it provides SearchContact method to search contact with filter. \par
\par
\pard\nowidctlpar\li720\b ContactType\b0 :\par
\pard\nowidctlpar\li1440 This enumeration represents the contact type. \par
\par
\pard\nowidctlpar\li720\b ContactFilterFactory\b0 :\par
\pard\nowidctlpar\li1440 This class is used to create pre-defined filters or AND/OR/NOT filters which are used to search contacts. The column names used in this factory are aliases. The SearchBundle will convert the aliases to the actual names defined in the SearchBundle configuration files.\par
\par
\pard\nowidctlpar\li720\cf2\b ContactHomeLocal\b0 :\par
\pard\nowidctlpar\li1440 The local interface of the Contact EJB\par
\par
\pard\nowidctlpar\li720\b ContactLocal\b0 :\par
\pard\nowidctlpar\li1440 The local component interface of the Contact EJB, which provides access to the persistent store for contacts managed by the application.\par
\par
\pard\nowidctlpar\li720\b ContactManagerLocalDelegate\b0 :\par
\pard\nowidctlpar\li1440 Implements the ContactManager interface to provide management of the Contact objects through the use of a local session EBJ. It will obtain the handle to the bean\rquote s local interface and will simply delegate all calls to it. It implements all methods.\par
\par
\pard\nowidctlpar\li720\b ContactBean\b0 :\par
\pard\nowidctlpar\li1440 The session EJB that handles the actual manager requests. It simply delegates all operations to the ContactDAO it obtains from the ObjectFactory.\par
\cf0\par
\pard\nowidctlpar\tab\par
\pard\nowidctlpar\li720\cf1\b AddressManager\b0 :\par
\pard\nowidctlpar\li1440 This interface defines the contract for the complete management of an address. It provides single and batch CRUD operations as well as the means to associate or disassociate an address from an entity. It also provides the ability to audit each operation, if so desired. It has one implementation in this design: AddressManagerLocalDelegate.\par
\pard\nowidctlpar\li720\cf0\b\f1\par
\f0 Address\b0 :\par
\pard\nowidctlpar\li1440 This class holds the information of an address. \par
\par
\pard\nowidctlpar\li720\b AddressDAO\b0 :\par
\pard\nowidctlpar\li1440 This interface specifies the contract for implementations of an Address DAOs. An AddressDAO is responsible for accessing the database. \par
\par
\pard\nowidctlpar\li720\b InformixAddressDAO\b0 :\par
\pard\nowidctlpar\li1440 This class is the Informix database implementation of the AddressDAO. It provides general retrieve/update/remove/add functionality to access the database. And it provides SearchAddresses method to search addresses with filter. \par
\par
\pard\nowidctlpar\li720\b AddressType\b0 :\par
\pard\nowidctlpar\li1440 This enumeration represents the address type. \par
\par
\pard\nowidctlpar\li720\b AddressFilterFactory\b0 :\par
\pard\nowidctlpar\li1440 This class is used to create pre-defined filters or AND/OR/NOT filters which are used to search addresses. The column names used in this factory are aliases. The SearchBundle will convert the aliases to the actual names defined in the SearchBundle configuration files.\par
\par
\pard\nowidctlpar\li720\b Country\b0 :\par
\pard\nowidctlpar\li1440 This class holds the information of a country.\par
\par
\pard\nowidctlpar\li720\b State\b0 :\par
\pard\nowidctlpar\li1440 This class holds the information of a state.\par
\par
\pard\nowidctlpar\li720\cf2\b AddressHomeLocal\b0 :\par
\pard\nowidctlpar\li1440 The local interface of the Address EJB\par
\par
\pard\nowidctlpar\li720\b AddressLocal\b0 :\par
\pard\nowidctlpar\li1440 The local component interface of the Address EJB, which provides access to the persistent store for addresses managed by the application.\par
\par
\pard\nowidctlpar\li720\b AddressManagerLocalDelegate\b0 :\par
\pard\nowidctlpar\li1440 Implements the AddressManager interface to provide management of the Address objects through the use of a local session EBJ. It will obtain the handle to the bean\rquote s local interface and will simply delegate all calls to it. It implements all methods.\par
\par
\pard\nowidctlpar\li720\b AddressBean\b0 :\par
\pard\nowidctlpar\li1440 The session EJB that handles the actual manager requests. It simply delegates all operations to the AddressDAO it obtains from the ObjectFactory.\par
\cf0\par
\f1\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\b\f0 1.5\tab\cf1 Usage of Exceptions\cf0\par
\pard\nowidctlpar\li720 ContactException\b0 :\par
\pard\nowidctlpar\li710 This exception will be the base exception for all exceptions thrown by the ContactManager/AddressManager classes. This exception can be used by the application to simply their exception processing by catching a single exception regardless of the actual subclass.\par
\par
\pard\nowidctlpar\li720\cf1\b IDGenerationException\cf0\b0 :\par
\pard\nowidctlpar\li710 This exception will be thrown by the Contact/AddressManager classes, \cf1 EJB entities\cf0 , and Contact/AddressDAO classes when ID can't be generated successfully. This exception will be exposed to the caller of addContact/Address method.\f1\par
\par
\pard\nowidctlpar\li720\cf1\b\f0 InvalidPropertyException\cf0\b0 :\par
\pard\nowidctlpar\li710 This exception will be thrown by the Contact/AddressManager classes, \cf1 EJB entities\cf0 , and Contact/AddressDAO classes when the property of the properties of given Contact is invalid. This exception will be exposed to the caller of addContact/Address(s) and updateContact/Address(s) method.\f1\par
\par
\pard\nowidctlpar\li720\cf1\b\f0 AuditException\cf0\b0 :\par
\pard\nowidctlpar\li710 This exception will be thrown by the Contact/AddressManager classes, \cf1 EJB entities\cf0 , and Contact/AddressDAO classes if they encounter any exception when try to audit. This exception will be exposed to the caller of addContact/Address(s), updateContact/Address(s) and removeContact/Address(s) methods.\f1\par
\par
\pard\nowidctlpar\li720\cf1\b\f0 PersistenceException\cf0\b0 :\par
\pard\nowidctlpar\li710 This exception will be thrown by the Contact/AddressManager classes, \cf1 EJB entities\cf0 , and Contact/AddressDAO classes when they encounter database exceptions. This exception will be exposed to the caller of database related methods.\f1\par
\par
\pard\nowidctlpar\li720\cf1\b\f0 ConfigurationException\cf0\b0 :\par
\pard\nowidctlpar\li710 This exception will be thrown by the \cf1 ContactManager/AddressManager and ContactDAO/AddressDAO implementations\cf0  when they encounter a configuration error. This exception will be exposed to the caller of constructor of ContactManager/AddressManager and ContactDAO/AddressDAO implementations.\f1\par
\par
\pard\nowidctlpar\li720\cf1\b\f0 BatchOperationException\cf0\b0 :\par
\pard\nowidctlpar\li710 This exception will be thrown by the Contact/AddressManager classes, \cf1 EJB entities\cf0 , and Contact/AddressDAO classes when any operation in the batch is failed. This exception will be exposed to the caller of batch operation methods.\par
\f1\par
\pard\nowidctlpar\li720\cf1\b\f0 EntityNotFoundException\cf0\b0 :\par
\pard\nowidctlpar\li710 This exception will be thrown by the Contact/AddressManager classes, \cf1 EJB entities\cf0 , and Contact/AddressDAO classes when trying to update the Contact/Address which can be not found. This exception will be exposed to the caller of updateContact/Address(s) updateContact/Address(s) methods.\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\f1\par
              \cf1  AssociationException\par
\cf0\tab      This exception indicates that an entry of Address/Contact is associated with multiple entities. According to design and specification, any given record of Address/Contact may be associated with zero/one entity at one time. It also may indicate    \par
              that the Address/Contact itself does not exist in persistence when trying to associating/deassociating it with some entity.\cf1\highlight4\ul\f5\par
\cf0\highlight0\ulnone\b\f0 1.6\tab\cf1 Thread Safety\cf0\par
\pard\nowidctlpar\li720\sa120\sl240\slmult0\cf3\b0 Contact, Address, Country and State are not thread-safe by being mutable. They are not supposed to be used in multi-thread environment. If they would be used in multi-thread environment, they should be synchronized externally.\par
\cf2 The classes in this component are thread-safe by being immutable and by the fact they are used in an EJB container, which assures that only one thread will use the session bean, and thus the DAO.\par
\pard\keepn\nowidctlpar\s1\sb120\sa60\sl240\slmult0\tx360\cf0\b\fs24 2.\tab Environment Requirements\tab\tab\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\fs20 2.1\tab Environment\par
\pard{\pntext\f0 1\tab}{\*\pn\pnlvlbody\pnf0\pnindent360\pnstart1\pndec }
\nowidctlpar\li1080\b0 Development language: Java 1.4\par
{\pntext\f0 2\tab}Compile target: Java 1.4, Java 1.5\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\b 2.2\tab TopCoder Software Components\par
\pard\nowidctlpar\fi-420\li1140\sa120\sl240\slmult0\tx1080\tx1140\cf3\f2\fs16 l\tab  \b0\f0\fs20 Configuration Manager 2.1.5 is used t\cf0 o provide configuration options\f1\fs24\par
\pard\nowidctlpar\fi-420\li1140\sa120\sl240\slmult0\b\f2\fs16 l\tab\b0\f0\fs20 Object Factory 2.0 is utilized to create the implementations of Contact/AddressDAO.\f1\fs24\par
\b\f2\fs16 l\tab\b0\f0\fs20 Base Exception 1.0 is used to provide a base for all custom exceptions.\f1\fs24\par
\b\f2\fs16 l\tab\b0\f0\fs20 ID Generator 3.0 is used to generate IDs for Address and Contact.\f1\fs24\par
\b\f2\fs16 l\tab\b0\f0\fs20 DB Connection Factory 1.0 is used to generate the database Connection. \f1\fs24\par
\b\f2\fs16 l\tab\b0\f0\fs20 Type Safe Enum 1.0 is used to be extended by the ContactType and AddressType enumeration. \f1\fs24\par
\b\f2\fs16 l\tab\b0\f0\fs20 Search Builder 1.3.1 is used to enable search with filter\par
\b\f2\fs16 l\tab\b0\f0\fs20 Database Abstraction 1.1 is used to provide a common set of Java classes that abstract the mapping of database data types to the corresponding java objects. \par
\b\f2\fs16 l\tab\b0\f0\fs20 Class Associations 1.0 is used to provide a way of associating a particular object (the 'handler') with a specific class or that class' subtypes (the 'target')\par
\b\f2\fs16 l\tab\b0\f0\fs20 Data Validation 1.0 is used to analyse objects to verify that the content meets defined rules\par
\b\f2\fs16 l\tab\b0\f0\fs20 Time Tracker Audit 3.2 is used to provide audit functionality\f1\fs24\par
\b\f2\fs16 l\tab\b0\f0\fs20 Time Tracker Common 3.1 provides TimeTrakerBean base class.\f1\fs24\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\b\f0\fs20 2.3\tab Third Party Components\par
\pard\nowidctlpar\s3\li720\sb120\sa60\sl240\slmult0\tx720\b0 None\par
\pard\keepn\nowidctlpar\s1\sb120\sa60\sl240\slmult0\tx360\b\fs24 3.\tab Installation and Configuration\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\fs20 3.1\tab\cf1 Package Name\cf0\par
\pard\nowidctlpar\li720\sa120\b0 com.topcoder.timetracker.contact\par
\cf2 com.topcoder.timetracker.contact.ejb\par
\cf0 com.topcoder.timetracker.contact.persistence\par
\pard\nowidctlpar\fi-420\li420\sa120\sl240\slmult0\tx420\b 3.2\tab\cf1 Configuration Parameters\cf0\par
\pard\nowidctlpar\fi-720\li720\sa120\sl240\slmult0\tx720\cf2\b0 3.2.1\tab ContactManagerLocalDelegate\par
\trowd\trgaph108\trleft-108\trbrdrl\brdrs\brdrw10 \trbrdrt\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trpaddl108\trpaddr108\trpaddfl3\trpaddfr3
\clcbpat5\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx1721\clcbpat5\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx5103\clcbpat5\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx7371\clcbpat5\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx8647\pard\intbl\nowidctlpar\cf0\b Property Name\cell Description\cell Details\cell Required\cell\row\trowd\trgaph108\trleft-108\trbrdrl\brdrs\brdrw10 \trbrdrt\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trpaddl108\trpaddr108\trpaddfl3\trpaddfr3
\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx1721\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx5103\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx7371\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx8647\pard\intbl\sa120\cf2\b0 jndi_reference\cell JNDI reference to the local contact EJB.\cell Example:\par
\ldblquote java:comp/env/ejb/ ContactLocal\rdblquote\cell Yes\cell\row\pard\nowidctlpar\sa120\sl240\slmult0\cf0\par
\pard\nowidctlpar\fi-720\li720\sa120\sl240\slmult0\tx720\cf2 3.2.2\tab AddressManagerLocalDelegate\par
\trowd\trgaph108\trleft-108\trbrdrl\brdrs\brdrw10 \trbrdrt\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trpaddl108\trpaddr108\trpaddfl3\trpaddfr3
\clcbpat5\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx1701\clcbpat5\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx5103\clcbpat5\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx7371\clcbpat5\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx8647\pard\intbl\nowidctlpar\cf0\b Property Name\cell Description\cell Details\cell Required\cell\row\trowd\trgaph108\trleft-108\trbrdrl\brdrs\brdrw10 \trbrdrt\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trpaddl108\trpaddr108\trpaddfl3\trpaddfr3
\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx1701\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx5103\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx7371\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx8647\pard\intbl\sa120\cf2\b0 jndi_reference\cell JNDI reference to the local address EJB.\par
Required\cell Example:\par
\ldblquote java:comp/env/ejb/ AddressLocal\rdblquote\cell Yes\cell\row\pard\nowidctlpar\sa120\sl240\slmult0\cf0\par
\pard\nowidctlpar\fi-720\li720\sa120\sl240\slmult0\tx720 3.2.3\tab InformixContactDAO\par
\pard\nowidctlpar\li720\sa120\sl240\slmult0 The InformixContactDAO has the following configuration using the specified namespaces (or one provided by the application or ContactManager):\par
\i Namespace\i0 : com.topcoder.timetracker.contact.persistence.InformixContactDAO\par
\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clcbpat5\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clcbpat5\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clcbpat5\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clcbpat5\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar\b Property Name\cell Description\cell Details\cell Required\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar\b0 connection_factory_namespace\f1\cell\f0 The namespace used to create DBConnectionFactory\cell String\cell Yes\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar connection_name\f1\cell\f0 The name used to get connection from connection factory\cell String\f1\cell\f0 No\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar idgenerator_name\cell The name used to get the IDGenerator\cell String\cell Yes\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar search_bundle_name\f1\cell\f0 The name will be used to get SearchBundle from SearchBundleManager\cell String\cell Yes\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar search_bundle_namespace\f1\cell\f0 The namespace used to create \f4 SearchBundleManager\f1\cell\f0 String\cell Yes\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar audit_manager_namespace\f1\cell\f0 The namespace of ObjectFactory used to create \f4 AuditManager\f1\cell\f0 String\cell Yes\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar AuditManager\f1\cell\f0 The object key of AuditManager within object specification\f1\cell\f0 String\cell Yes\cell\row\pard\nowidctlpar\fi-720\li720\sa120\sl240\slmult0\tx720\f1\par
\tab\f0 NOTE: all the aliases used in the ContactFilterFactory should be defined in the alias property of the configuration file.\f1\par
\pard\nowidctlpar\sa120\sl240\slmult0\f0\par
\pard\nowidctlpar\fi-720\li720\sa120\sl240\slmult0\tx720 3.2.4\tab InformixAddressDAO\par
\pard\nowidctlpar\li720\sa120\sl240\slmult0 The InformixAddressDAO has the following configuration using the specified namespaces (or one provided by the application or AddressManager):\par
\i Namespace\i0 : com.topcoder.timetracker.address.persistence.InformixAddressDAO \f1\par
\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clcbpat5\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clcbpat5\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clcbpat5\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clcbpat5\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar\b\f0 Property Name\cell Description\cell Details\cell Required\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar\b0 connection_factory_namespace\cell The namespace used to create DBConnectionFactory\cell String\cell Yes\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar connection_name\cell The name used to get connection from connection factory\cell String\cell No\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar idgenerator_name\cell The name used to get the IDGenerator\cell String\cell Yes\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar search_bundle_name\cell The name will be used to get SearchBundle from SearchBundleManager\cell String\cell Yes\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar search_bundle_namespace\cell The namespace used to create \f4 SearchBundleManager\f1\cell\f0 String\cell Yes\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar audit_manager_namespace\f1\cell\f0 The namespace of ObjectFactory used to create \f4 AuditManager\f1\cell\f0 String\cell Yes\cell\row\trowd\trgaph10\trleft142\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx3119\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx6645\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx7655\clbrdrl\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw5\brdrs\brdrcf3 \cellx8931\pard\intbl\nowidctlpar AuditManager\f1\cell\f0 The object key of AuditManager within object specification\f1\cell\f0 String\cell Yes\cell\row\pard\nowidctlpar\li720\sa120\sl240\slmult0\par
NOTE: all the aliases used by the AddressFilterFactory should be defined in the alias property of the configuration file. \f1\par
\pard\nowidctlpar\sa120\sl240\slmult0\f0\par
\pard\nowidctlpar\fi-720\li720\sa120\sl240\slmult0\tx720 3.2.5\tab Sample Configurations\par
\pard\nowidctlpar\li720\sa120\sl240\slmult0 Please refer to contact_config.xml and address_config.xml for J2SE configuration. \cf2 For J2EE configuration, please refer to contact_j2ee_config.xml, address_j2ee_config.xml, and the sample deployment descriptor ejb-jar.xml. All are in the docs directory.\cf0\par
\pard\keepn\nowidctlpar\s2\fi-720\li720\sb120\sa60\sl240\slmult0\tx0\tx720\b 3.3\tab\cf1 Dependencies Configuration\cf0\par
\pard\fi720\sa120\qj\b0 The dependency components should be configured according to their documentation.\par
\pard\li720\sa120\cf2 The EJB deployment descriptor must have a data source configured for the DBConnection Factory. Also, it must include the following two environment entries for the CompanyBean:\par
\pard\li720\sa120\qj\cf0\par
\trowd\trgaph108\trleft-108\trbrdrl\brdrs\brdrw10 \trbrdrt\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trpaddl108\trpaddr108\trpaddfl3\trpaddfr3
\clcbpat5\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx2309\clcbpat5\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx5894\clcbpat5\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx9252\pard\intbl\nowidctlpar\b\fs24 Parameter\fs20\cell\fs24 Description\fs20\cell\fs24 Details\fs20\cell\row\trowd\trgaph108\trleft-108\trbrdrl\brdrs\brdrw10 \trbrdrt\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trpaddl108\trpaddr108\trpaddfl3\trpaddfr3
\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx2309\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx5894\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx9252\pard\intbl\sa120\cf2\b0 SpecificationNamespace\cell Namespace to use with the ConfigManagerSpecificationFactory\par
Required\cell Example:\par
\ldblquote com.topcoder.specification\rdblquote\cell\row\trowd\trgaph108\trleft-108\trbrdrl\brdrs\brdrw10 \trbrdrt\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trpaddl108\trpaddr108\trpaddfl3\trpaddfr3
\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx2309\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx5894\clbrdrl\brdrw10\brdrs\clbrdrt\brdrw10\brdrs\clbrdrr\brdrw10\brdrs\clbrdrb\brdrw10\brdrs \cellx9252\pard\intbl\sa120 ContactDAOKey\par
AddressDAOKey\cell Key to the CompanyDAO/ AddressDAO instance to pass to object factory\par
Required.\cell\ldblquote companyDAOKey\rdblquote\par
\ldblquote addressDAOKey\rdblquote\cell\row\pard\nowidctlpar\li720\sa120\sl240\slmult0 The sample deployment descriptor introduced in 3.2.5 has a simple example of these entries being used.\par
\pard\keepn\nowidctlpar\s1\sb120\sa60\sl240\slmult0\tx360\cf0\b\fs24 4.\tab Usage Notes\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\fs20 4.1\tab Required steps to test the component\par
\pard\nowidctlpar\fi-360\li1080\sa120\tx1080\lang2052\b0\f6\fs24\'b7\lang1033\b\f7\fs20\tab\b0\f0  Extract the component distribution.\f1\fs24\par
\pard\nowidctlpar\fi-360\li1080\sa120\lang2052\f6\'b7\lang1033\b\f7\fs20\tab\b0\f0  Follow \cf1\ul Dependencies Configuration.\cf0\ulnone\f1\fs24\par
\lang2052\f6\'b7\lang1033\b\f7\fs20\tab\b0\f0  Execute ant test\f1\fs24\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\b\f0\fs20 4.2\tab Required steps to use the component\par
\pard\nowidctlpar\li720\sa120\sl240\slmult0\b0 Nothing special required\par
\pard\keepn\nowidctlpar\s2\sb120\sa60\sl240\slmult0\tx0\b 4.3\tab\cf1 Demo\cf0\par
\pard\nowidctlpar\li720\sa120\sl240\slmult0\b0 Demo of Address is same with contact, \cf2 except for the retrieval of all states and countries. This will be demoed in 4.3.5.\par
For the purposes of this demo, the configuration introduced in 3.2.5 can be used.\cf0\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\cf1\i 4.3.1\tab Create ContactManagerLocalDelegate\par
\pard\nowidctlpar\li720\i0\f1\fs18\par
\f0 //Create a new ContactManagerLocalDelegate, the default namespace will be used\par
\f4 ContactManagerLocalDelegate manager = new ContactManagerLocalDelegate();\par
\f0\par
// Create a new ContactManagerLocalDelegate with namespace\par
\pard\nowidctlpar\li720\sa120\f4 ContactManagerLocalDelegate manager = new ContactManagerLocalDelegate( \ldblquote com.topcoder.timetracker.contact.ContactManagerLocalDelegate\rdblquote );\par
\pard\nowidctlpar\li720\cf0\i\f1\fs20\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\f0 4.3.2\tab Manager Contacts\par
\pard\nowidctlpar\li720\i0\f1\fs18\par
\f0 //Add the contacts by contact manager, contacts is Contact[], and this action will be audited\par
manager.addContacts(contacts, true);\par
\f1\fs24\par
\f0\fs18 //get all contacts by manager\par
Contact[] contacts = manager.getAllContacts();\par
\par
//remove one contact, this action will be audited\par
manager.removeContact(Contact[1].getId(), true);\par
\par
//change the country of one\par
contacts[3].setCountry(country_us)\f1\par
\par
\f0 //Update the contact, this action will be audited\par
manager.updateContact(contacts[3], true);\par
\par
\pard\keepn\nowidctlpar\s3\sb120\sa60\sl240\slmult0\tx0\i\fs20 4.3.3\f1\tab\f0 Search Contacts\par
\pard\nowidctlpar\li720\i0\f1\fs24\par
\f0\fs18 //Create filter with country US\par
Filter myFilter = ContactFilterFactory.createCountryFilter(country_us);\f1\par
\par
\f0 //search with this filter, the result will include the contacts whose country is US\par
Contact[] contacts = manager.searchContacts(myFilter);\par
\par
\pard\keepn\nowidctlpar\s3\fi-840\li840\sb120\sa60\sl240\slmult0\tx0\tx840\i\fs20 4.3.4\tab Manage Contact Relation\par
\pard\nowidctlpar\li720\i0\fs18 //Add the contact when adding a client, a client is come from Time Tracker Client component, it contains contact and address, this action won't be audited\par
manager.addContact(client.getContact(), false);\par
\par
//Associate the contact with this client, this action won't be audited\par
manager.associate(client.getContact(), client.getId(), false);\par
\par
\par
//Deassociate the contact with the client, this action won't be audited\par
manager.deassociate(client.getContact(), client.getId(), false);\par
\par
//remove the contact when removing a client, this action won't be audited\par
manager.removeContact(client.getContact().getId(), false);\par
\pard\nowidctlpar\fs24\par
\pard\keepn\nowidctlpar\s3\fi-840\li840\sb120\sa60\sl240\slmult0\tx0\tx840\cf2\i\fs20 4.3.5\tab Retrieve State and Country data\par
\pard\nowidctlpar\li720\i0\fs18 //Assume that an AddressManager instance is created in the same manner as the ContactManager //in 4.3.1. Use it for the following actions. \par
\par
// Get all states\par
State[] states = addressManager.getAllStates();\par
\par
// Get all countries\par
Country[] countries = addressManager.getAllCountries();\par
\cf0\par
\par
\pard\keepn\nowidctlpar\s1\sb120\sa60\sl240\slmult0\tx360\b\fs24 5.\tab Future Enhancements\par
\pard\keepn\nowidctlpar\s1\li710\sb120\sa60\sl240\slmult0\tx360\cf3\b0\fs20 Implement accessibility for other database systems.\par
\pard\nowidctlpar\cf0\f1\fs24\par
}
 