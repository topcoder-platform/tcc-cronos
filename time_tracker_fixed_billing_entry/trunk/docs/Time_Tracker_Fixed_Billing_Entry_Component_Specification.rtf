{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fprq2\fcharset2 Symbol;}{\f2\fmodern\fprq1\fcharset0 Courier New;}}
{\colortbl ;\red0\green0\blue255;\red0\green0\blue0;}
{\*\generator Msftedit 5.41.15.1507;}\viewkind4\uc1\pard\keepn\nowidctlpar\li283\sb120\sa60\sl240\slmult0\tx1003\ul\b\f0\fs28 Time Tracker Fixed Billing Entry version 1.0 Component Specification\par
\pard\nowidctlpar\li720\sa120\ulnone\b0\fs20\par
\pard\keepn\nowidctlpar\sb120\sa60\sl240\slmult0\tx0\tx77\b\fs24 1.Design\par
\pard\nowidctlpar\li720\b0\fs20 The Time Tracker Fixed Billing Entry custom component is part of the Time Tracker application.  It provides an abstraction of Fixed Billing Entries.  This component handles the persistence and other business logic required by the application.\par
\par
The design is separated into 2 layers of management: The topmost layer are the Manager classes, which provide the functionality needed to update, retrieve and search from the data store.  Batch operations are also available in the Manager classes.  The next layer are the DAOs, which interact directly with the data store.  There is also a sublayer, called the FilterFactory layer, which are responsible for building search filters which can be used to build the search filter.\par
\par
There is an additional J2EE layer on top of the component.  This layer is composed of a SessionBean and a BusinessDelegate.  The SessionBean is stateless, and supports local interfaces.  The BusinessDelegate doubles as a service locator, and looks up the Session Bean upon construction, delegating all similar method calls to the SessionBean.  This layer is responsible for transactions, allowing a J2EE container to manage transactions for the component.\par
\par
\i\par
\pard\nowidctlpar\tx720\b\i0 1.1Design Patterns \par
\b0\fs24\par
\pard\nowidctlpar\li720\sa120\sl240\slmult0\b\i\fs20 The Strategy Pattern.\b0  The DAO classes such as FixedBillingEntryDAO and FixedBillingStatusDAO are strategies for persisting and retrieving information from a data store.\i0\fs24\par
\b\i\fs20 The Facade Pattern.\b0  The manager classes [FixedBillingEntryManager, FixedBillingStatusManager]  encapsulate subsystem DAOs and other components to provide a unified API that makes it easier to manage the entries.\par
\b The Factory Pattern.\b0  The Factory pattern is used in the FilterFactory layer to create search filters.  The FixedBillingEntryFilterFactory and FixedBillingStatusFilterFactory employ this pattern.\i0\fs24\par
\pard\nowidctlpar\li720\sa120\b\i\fs20 The Business Delegate Pattern.\b0  The Business Delegate pattern is used with the FixedBillingEntryDelegate and FixedBillingStatusDelegate classes.\par
\b The Service Locator Pattern. \b0 The above-mentioned classes also double as Service Locators. \i0\par
\pard\nowidctlpar\sa120\par
\pard\nowidctlpar\tx0\b 1.2Industry Standards \par
\pard\nowidctlpar\li720\sa120\sl240\slmult0\b0\i JDBC 3.0\par
EJB 2.1\par
\pard\nowidctlpar\sa120\i0\par
\pard\nowidctlpar\tx0\b 1.3Required Algorithms\par
\pard\nowidctlpar\li720\sb120\b0 There were no algorithms required and the component is straightforward enough.  We will discuss the database schema, and the method of searching in this section.\par
\pard\nowidctlpar\fs24\par
\pard\nowidctlpar\fi-360\li742\tx382\tx742\i\fs18 1.3.1 \fs20 Data Mapping\i0\fs24\par
\pard\nowidctlpar\li720\tx670\fs20 This section will deal with mapping the different values in the beans to their respective columns. The developer is responsible for generating the necessary SQL to insert/retrieve the data in the beans from the appropriate columns.  The SQL will require some simple table joins at the most.  Please refer to the ERD diagrams for more information [see TimeTrackerFixedBillingEntry_ERD.jpg].\par
\par
\ul 1.3.1.1 FixedBillingEntry Class and fix_bill_entry Table\ulnone\par
\pard\nowidctlpar\fi-360\li1440\tx670\tx1440\f1\'b7\tab\f0 Column fix_bill_entry_id maps to the id property in the TimeTrackerBean base class.  \i\par
\pard\nowidctlpar\li1080\tx670\tab Note: The id generator is used to create a new id when a new record is inserted.\par
\i0\par
\pard\nowidctlpar\fi-360\li1440\tx670\tx1440\f1\'b7\tab\f0 Column company_id maps to the companyId property in the BaseEntry superclass.\par
\pard\nowidctlpar\fi-360\li1440\f1\'b7\tab\f0 Column fix_bill_type_id does not map to anything [it was clarified in the forums that it was not needed]\par
\f1\'b7\tab\f0 Column fix_bill_status_id maps to the FixedBillingStatus property in the FixedBillingEntry class.\tab\par
\f1\'b7\tab\f0 Column description maps to the description property in the FixedBillingEntry class.\par
\f1\'b7\tab\f0 Column entry_date maps to the entryDate property in the BaseEntry superclass.\par
\f1\'b7\tab\f0 Column amount maps to the amount property in the FixedBillingEntry class.\par
\f1\'b7\tab\f0 Column creation_date maps to the creationDate property in the TimeTrackerBean base class.\par
\f1\'b7\tab\f0 Column creation_user maps to the creationUser property in the TimeTrackerBean base class.\par
\f1\'b7\tab\f0 Column modification_date maps to the modificationDate property in the TimeTrackerBean base class.\par
\f1\'b7\tab\f0 Column modification_user maps to the modificationUser property in the TimeTrackerBean base class.\par
\f1\'b7\tab\f0 Column invoice_id maps to the invoice id property in the FixedBillingEntry class.\par
\pard\nowidctlpar\li720\tx670\tab\b\par
\b0\tab\par
\ul 1.3.1.2 FixedBillingStatus Class and fix_bill_status Table\par
\pard\nowidctlpar\fi-360\li1440\tx670\tx1440\ulnone\f1\'b7\tab\f0 Column fix_bill_status_id maps to the id property in the TimeTrackerBean base class.  \par
\pard\nowidctlpar\li1080\tx670\i\tab Note: The id generator is used to create a new id when a new record is inserted.\par
\i0\par
\pard\nowidctlpar\fi-360\li1440\tx670\tx1440\f1\'b7\tab\f0 Column description maps to the description property in the FixedBillingStatus class.  \par
\pard\nowidctlpar\fi-360\li1440\f1\'b7\tab\f0 Column creation_date maps to the creationDate property in the TimeTrackerBean base class.\par
\f1\'b7\tab\f0 Column creation_user maps to the creationUser property in the TimeTrackerBean base class.\par
\f1\'b7\tab\f0 Column modification_date maps to the modificationDate property in the TimeTrackerBean base class.\par
\f1\'b7\tab\f0 Column modification_user maps to the modificationUser property in the TimeTrackerBean base class.\par
\pard\nowidctlpar\li720\tx670\par
\par
\pard\nowidctlpar\li368\i 1.3.2 Searching\par
\pard\nowidctlpar\li1440\tab\tab\i0\par
\pard\nowidctlpar\li1134\sb57 Searching is executed in this component by using the Search Builder component and the FilterFactory layer.  First off, the developer needs to develop a search query off which to base the search on.  The search query will retrieve all the necessary attributes, and join with the tables of any possible criterion.  Once a query has been defined, in the constructor, the appropriate FilterFactory will be initialized with the column names used in the query.  This FilterFactory can then be returned by the appropriate getFilterFactory method.\par
\par
The user may then use the Factory to build the search filters.  Once the filters are provided back to the DAO implementation, it may use the DatabaseSearchStrategy to build the search.  The DatabaseSearchStrategy will then add the necessary WHERE clauses to constrain the search to the search criterion specified in the Filters.\par
\par
\b Example:\par
\b0\par
The following query may be used as the context for searching the FixedBillingEntries(we reduce the retrieved data to only the id, but developer may modify it to retrieve all relevant fields):\par
\tab\f2 SELECT \par
\tab\tab fix_bill_entry_id\par
\tab FROM\par
\tab\tab fix_bill_entry\par
\tab INNER JOIN\par
\tab\tab fb_reject_reason\par
\tab\tab ON\tab\par
\tab\tab fix_bill_entry.fix_bill_entry_id = fb_reject_reason.fix_bill_entry_id\par
\f0\tab\f2 WHERE\par
\f0\par
From this context, the Search Builder can then add the different WHERE clauses, depending on the filter that was provided.  For example, if a filter for the description was created using createCreationDateFilter, then the Search Builder would add:\par
\tab\f2 WHERE (continued from above)\par
\tab\tab fix_bill_entry.creation_date = [value of filter]\par
\f0\par
To accomplish this, in the constructor of the DAO, the FilterFactory must be configured according to the context query that was used.  In this example, the mapped value for the CREATION_DATE_COLUMN_NAME should be "fix_bill_entry.creation_date".  \par
\par
Finally, note that this may be optimized by adding a GROUP BY clause to group the results by ids (this is especially important if a reject reason filter is not specified, since it would return multiple rows for each reject reason in a given filter).  The GROUP BY clause may be manually added by calling the buildSearchContext method, and adding the GROUP BY clause after the buildSearchContext has been completed.  This will need to be done in a private inner subclass of SearchStrategy.\par
\pard\nowidctlpar\li368\i\par
1.3.3 Auditing\par
\tab\i0 The method implementation notes contain the audit header information that should be used when performing the audit.  The following clarifies how to create AuditDetail objects to add to the AuditHeader.  When creating a new entry (audit header action type is CREATE), then the oldValue for each detail is null.  When deleting an entry (audit header action type is DELETE), then the newValue for each detail is null.  When updating an entry, the old value is retrieved from the datastore to populate the AuditDetail's old value. \i\par
\par
1.3.4 Batch Operations\par
\tab\i0 The DbDAO classes have a useBatching variable assigned to them.  If this is true, then the developer should use the \i addBatch \i0 method with PreparedStatements when performing batch operations.  All batch methods in the DAO should be atomic, and so if a BatchUpdateException occurs, then the entire batch must be rolled-back, to ensure consistency between different JDBC drivers.   Note that batching is not required for DELETE statements, since an IN clause may be used for that.\par
\par
\i 1.3.5 Configuration via Object Factory\par
\tab\i0 The component relies on the Object Factory for configuration.  A sample configuration file has been provided in the docs directory.  Initializing the Manager classes simply consists of calling the \i createObject\i0  method with the appropriate class argument.\par
\par
\pard\nowidctlpar\li1134\sb57\fs16\par
\pard\nowidctlpar\tx0\b\fs20 1.4Component Class Overview\par
\tab Package com.topcoder.time.tracker.entry.fixedbilling\par
\tab FixedBillingEntryManager (interface)\par
\pard\nowidctlpar\li720\b0\tab This interface represents the API that may be used in order to manipulate the various details involving a Time Tracker Fixed Billing Entry.  CRUDE and search methods are provided to manage the Time Entries inside a persistent store.  There are also methods for the manipulation of RejectReasons associated with the FixedBillingEntry.\par
\par
\b FixedBillingEntryDAO (interface)\par
\b0\tab This is an interface definition for the DAO that is responsible for handling the retrieval, storage, and searching of Time Tracker FixedBillingEntry data from a persistent store.  It is also responsible for generating ids for any entities within it's scope, whenever an id is required.\par
\par
\b FixedBillingEntryFilterFactory (interface)\par
\b0\tab This interface defines a factory that is capable of creating search filters used for searching through Time Tracker FixedBillingEntries.  It offers a convenient way of specifying search criteria to use.  The factory is capable of producing filters that conform to a specific schema, and is associated with the FixedBillingEntryManager that supports the given schema.\b\par
\pard\nowidctlpar\tx0\par
\tab BaseFilterFactory (interface)\par
\pard\nowidctlpar\li720\b0\tab This is a base FilterFactory interface that provides filter creation methods that may be used for filters of any Time Tracker Bean.  It encapsulates filters for the common functionality - namely, the creation and modification date and user.\b\par
\pard\nowidctlpar\tx0\tab\par
\tab FixedBillingEntryRejectReasonDAO (interface)\par
\pard\nowidctlpar\li720\tab\b0 This is an interface definition for the DAO that is responsible for handling the association between Time Tracker FixedBillingEntries and the Reject Reasons.  Simple CRUDE methods are specified.\par
\par
\b FixedBillingStatusManager (interface)\par
\b0\tab This interface represents the API that may be used in order to manipulate the various details involving a FixedBillingStatus.  CRUDE and search methods are provided to manage the FixedBillingStatuses inside a persistent store.\par
\par
\pard\nowidctlpar\tx0\b\tab FixedBillingStatusDAO (interface)\par
\pard\nowidctlpar\fi-720\li720\tab\tab\b0 This is an interface definition for the DAO that is responsible for handling the retrieval, storage,and searching of FixedBillingStatus data from a persistent store.  It is also responsible for generating ids for any entities within it's scope, whenever an id is required.\par
\b\par
\pard\nowidctlpar\tx0\tab FixedBillingStatusFilterFactory (interface)\par
\pard\nowidctlpar\fi-720\li720\tab\tab\b0 This interface defines a factory that is capable of creating search filters used for searching through FixedBillingStatuses.  It offers a convenient way of specifying search criteria to use.  The factory is capable of producing filters that conform to a specific schema, and is associated with the FixedBillingStatusManager that supports the given schema.\par
\b\par
\pard\nowidctlpar\tx0\tab StringMatchType\par
\pard\nowidctlpar\fi-720\li720\tab\tab\b0 This is an enum that is used by the FilterFactories for those methods when a String criterion is specified.  This gives the user a convenient way of specifying the method of matching the Strings.\par
\b\par
\pard\nowidctlpar\tx0\tab FixedBillingEntry\par
\pard\nowidctlpar\fi-720\li720\tab\tab\b0 This is the main data class of the component, and includes getters and setters to access the various properties of a Fixed Billing Entry,   A Fixed Billing Entry is an amount of money spent by a Project Manager for a specific Project and client.\par
\par
\pard\nowidctlpar\tx0\b\tab FixedBillingStatus\par
\pard\nowidctlpar\fi-720\li720\tab\tab\b0 This is a bean that represents a FixedBillingEntryStatus, which represents a possible state that a FixedBillingEntry can have in the context of the Time Tracker system.\par
\par
\par
\pard\nowidctlpar\tx0\b\tab FixedBillingManagerImpl\par
\pard\nowidctlpar\fi-720\li720\tab\tab\b0 This is a default implementation of the FixedBillingEntryManager interface.  it utilizes instances of the FixedBillingEntryDAO in order to fulfill the necessary CRUDE and search operations defined for the Time Tracker FixedBillingEntries.  It also uses FixedBillingEntryRejectReasonDAO to associate any RejectReasons with the FixedBillingEntries.\par
\par
\pard\nowidctlpar\tx0\b\tab FixedBillingStatusManagerImpl\par
\pard\nowidctlpar\fi-720\li720\tab\tab\b0 This is a default implementation of the FixedBillingStatusManager interface.  it utilizes instances of the FixedBillingStatusDAO in order to fulfill the necessary CRUDE and search operations defined for the Time Tracker FixedBillingStatuses.\par
\par
\pard\nowidctlpar\tx0\b\tab ManagerFactory\par
\pard\nowidctlpar\fi-720\li720\tab\tab\b0 This is a class that acts as a factory for the managers, and may be used to easily access the manager class for various purposes.  It uses lazy instantiation to create the managers.  Instantiation is done through the Object Factory.\par
\par
\par
\pard\nowidctlpar\tx0\b\tab Package com.topcoder.time.tracker.entry.fixedbilling.db\par
\par
\pard\nowidctlpar\li720 BaseDAO\par
\b0\tab This is a base DAO class that encapsulates the common elements that may be found within a DAO such as the connection details, id generator, search strategy and audit manager.\par
\par
\b DbFixedBillingEntryDAO\par
\b0\tab This is an implementation of the FixedBillingEntryDAO interface that utilizes a database with the schema provided in the Requirements Section of Time Tracker Fixed Billing  Entry 3.1.  \par
\b\par
DbFixedBillingStatusDAO\par
\b0\tab This is an implementation of the FixedBillingStatusDAO interface that utilizes a database with the schema provided in the Requirements Section of Time Tracker Fixed Billing  Entry 3.1.\par
\par
\par
\b DbFixedBillingEntryRejectReasonDAO\par
\b0\tab This is an implementation of the DbFixedBillingEntryRejectReasonDAO interface that utilizes a database with the schema provided in the Requirements Section of Time Tracker Fixed Billing  Entry 3.1.\par
\par
\pard\nowidctlpar\tx0\b\tab Package com.topcoder.time.tracker.entry.fixedbilling.filterfactory\par
\pard\nowidctlpar\li720\par
 MappedBaseFilterFactory\par
\b0\tab This is an implementation of the BaseFilterFactory that may be used to build filters.\par
\b\par
 MappedFixedBillingStatusFilterFactory\par
\b0\tab This is an implementation of the FixedBillingStatusFilterFactory that may be used to build filters.\par
\b\par
 MappedFixedBillingEntryFilterFactory\par
\b0\tab This is an implementation of the FixedBillingEntryFilterFactory that may be used to build filters.\par
\b\par
\pard\nowidctlpar\tx0\tab Package com.topcoder.time.tracker.entry.fixedbilling.filterfactory\par
\pard\nowidctlpar\li720\par
FixedBillingEntryManagerDelegate\par
\b0\tab This is a Business Delegate/Service Locator that may be used within a J2EE application.  It is responsible for looking up the local interface of the SessionBean for FixedBillingEntryManager, and delegating any calls to the bean.\par
\b\par
FixedBillingStatusManagerDelegate\par
\b0\tab This is a Business Delegate/Service Locator that may be used within a J2EE application.  It is responsible for looking up the local interface of the SessionBean for FixedBillingStatusManager, and delegating any calls to the bean.\par
\par
\b FixedBillingEntrySessionBean\par
\b0\tab This is a Stateless SessionBean that is used to provided business services to manage FixedBillingEntries within the Time Tracker Application. It contains the same methods as FixedBillingEntryManager, and delegates to an instance of FixedBillingEntryManager.\par
\par
\b FixedBillingStatusSessionBean\par
\b0\tab This is a Stateless SessionBean that is used to provided business services to manage FixedBillingStatuses within the Time Tracker Application. It contains the same methods as FixedBillingStatusManager, and delegates to an instance of FixedBillingStatusManager.\b\par
\par
FixedBillingEntryManagerLocal\par
\tab\b0 Local interface for FixedBillingEntryManager.  It contains exactly the same methods\par
as FixedBillingEntryManager interface.\par
\par
\b FixedBillingStatusManagerLocal\par
\tab\b0 Local interface for FixedBillingStatusManager.  It contains exactly the same methods\par
as FixedBillingStatusManager interface.\par
\par
\b FixedBillingEntryManagerLocalHome\b0\par
\tab LocalHome interface for the FixedBillingEntryManager.  It contains only a single no-param create method that produces an instance of the local interface.  it is used to obtain a handle to the Stateless SessionBean.\par
\par
\b FixedBillingStatusManagerLocalHome\b0\par
\tab LocalHome interface for the FixedBillingStatusManager.  It contains only a single no-param create method that produces an instance of the local interface.  it is used to obtain a handle to the Stateless SessionBean.\b\par
\par
\pard\nowidctlpar\li1140\b0\par
\pard\nowidctlpar\tx0\b 1.5Component Exception Definitions\par
\pard\nowidctlpar\li720 DataAccessException \par
\b0\tab This exception is thrown when a problem occurs while this component is interacting with the persistent store.  It is thrown by all the DAO and Manager interfaces (and their respective implementations).\par
\pard\nowidctlpar\b\fs24\par
\pard\nowidctlpar\li720\fs20 UnrecognizedEntityException\par
\b0\tab This exception is thrown when interacting with the data store and an entity cannot be recognized.  It may be thrown when an entity with\par
a specified identifier cannot be found.  It is thrown by all the Manager and DAO interfaces (and their implementations).\par
\pard\nowidctlpar\b\fs24\par
\pard\nowidctlpar\li720\fs20 InvalidCompanyException\par
\b0\tab This exception is thrown when there is an attempt to relate a Time Tracker entities to a FixedBillingEntry whose companies do not match.  For example, adding a RejectReason to a FixedBillingEntry when their companies are different.\par
\b\par
ConfigurationException\par
\b0\tab This exception is thrown when there are problems with configuration.\par
\par
\b InvalidFilterException\par
\b0\tab This exception is thrown when there is request to perform a search with filters that cannot be recognized by the given DAO or Manager class.\par
\b\par
BatchOperationException\par
\b0\tab This exception is thrown during batch operations where one or more of the elements in the batch failed to be processed properly.  It will contain an array of causes: each element that managed to be processed successfully will have a null for the corresponding element in the causes array, and each element that failed to be processed will have an Exception detailing the reason for failure in the causes array.\b\par
\par
\pard\nowidctlpar\fs24\par
\pard\nowidctlpar\tx0\fs20 1.6Thread Safety\par
\pard\nowidctlpar\fs24\par
\pard\nowidctlpar\li735\sa120\b0\fs20 This component is not completely thread-safe, The Bean instances are not thread safe, and it is expected to be used concurrently only for read-only access.  Otherwise, each thread is expected to work with its own instance.\par
The Manager classes are required to be thread safe, and achieves this via the thread safety of the implementations of the DAO Layer, and the FilterFactory Layer.  \par
The DAOLayer is made thread safe through the use of transactions, and is achieved with the transaction level of READ_COMMITTED.\par
The FilterFactory layer is thread-safe by virtue of being immutable.\par
\pard\keepn\nowidctlpar\sb120\sa60\sl240\slmult0\tx0\tx77\b\fs24 2.Environment Requirements\tab\tab\par
\pard\nowidctlpar\tx0\fs20 2.1Environment\par
\pard\nowidctlpar\li735\sa57\b0 Java 1.4\par
\par
\pard\nowidctlpar\tx0\b 2.2TopCoder Software Components\par
\pard\nowidctlpar\li720\sa57 DB Connection Factory 1.0\b0  \endash  for creating the DB connections.  The Connection Factory may be configured to retrieve connections from the JBoss TXDataSource if desired.\fs24\par
\b\fs20 Base Exception 1.0\b0  \endash  base class for custom exception is taken from it\fs24\par
\b\fs20 Object Factory 2.0.1\b0  \endash  is indirectly used to configure the component.\par
\b ID Generator 3.0\b0  \endash  for generating IDs in the persistence implementation.\par
\b TypeSafe Enum 1.0\b0  \endash  is used for the StringMatchType enum.\b\par
Search Builder 1.3.1\b0  \endash  is used to perform the searches\par
\b Class Associations 1.0\b0  - is userd in the Search Builder\par
\b JNDI Context Utility 1.0 - \b0 is used by the business delegates to look up the home interface of the session bean.\b\par
ConfigManager 2.1.5 \b0\endash  was not used because it relies on Object Factory for configuration.\b\par
Time Tracker Audit 3.1\b0  \endash  is used to perform the optional audit.\par
\b Time Tracker Base Entry 3.1\b0  \endash  is used to provide the base entry class.\par
\b Time Tracker Reject Reason 3.1\b0  \endash  is used to retrieve the RejectReason information.\b\par
Time Tracker Common 3.1\b0  \endash  is used to provide the TimeTrackerBean base class.\par
\b Database abstraction 1.0\b0  \endash  the search builder need this one.\par
\par
\pard\nowidctlpar\tx0\b 2.3Third Party Components\par
\pard\nowidctlpar\li720\b0 None\par
\pard\nowidctlpar\li720\sb120\sa60\sl240\slmult0\tx720\i\par
\pard\keepn\nowidctlpar\sb120\sa60\sl240\slmult0\tx0\tx77\b\i0\fs24 3.Installation and Configuration\par
\pard\nowidctlpar\tx0\fs20 3.1Package Names\par
\pard\nowidctlpar\li720\b0 com.topcoder.time.tracker.entry.fixedbilling\par
com.topcoder.time.tracker.entry.fixedbilling.db\par
com.topcoder.time.tracker.entry.fixedbilling.filterfactory\par
com.topcoder.time.tracker.entry.fixedbilling.j2ee\par
\par
\par
\pard\nowidctlpar\par
\pard\nowidctlpar\tx0\b 3.2Configuration Parameters\par
\pard\nowidctlpar\li720\b0 This component relies on Object Factory 2.0 for configuration that is based from a file.  See the sample configuration file (docs/Time_Tracker_Fixed_Billing_Entry_Object_Factory_Sample_Config.xml) provided on how to configure Object Factory to do this.\par
\par
For the j2ee portion, the following config parameters are used by all business delegates:\par
\par
\ul\b For FixedBillingEntryManagerDelegate and FixedBillingStatusManagerDelegate:\par
\par
\ulnone Property Name: \b0\i contextName\i0\par
\b Property Description: \b0 This is the context name used to retrieve the home object of the respective session bean.  If not specified, then the default context provided by JNDIUtils is used.\par
\b Is Required: \b0\i Optional\par
\ul\b\par
\ulnone\i0 Property Name: \b0\i localHomeName\i0\par
\b Property Description: \b0 This is the name used to retrieve the LocalHome.\par
\b Is Required: \b0\i Required\ul\b\i0\par
\ulnone\b0\par
\par
\pard\nowidctlpar\tx0\b 3.3Dependencies Configuration\par
\pard\nowidctlpar\li720\b0 All the dependencies are to be configured according to their component specifications.\par
\par
Do note that the default configuration for Search Builder is desired to be able to build the search string correctly.\par
\pard\nowidctlpar\li720\sa120\sl240\slmult0\cf1\i\par
\pard\keepn\nowidctlpar\sb120\sa60\sl240\slmult0\tx0\tx77\cf0\b\i0\fs24 4.Usage Notes\par
\pard\nowidctlpar\tx0\fs20 4.1Required steps to test the component\par
\pard\nowidctlpar\li720\sa120\b0 Extract the component distribution.\par
Follow Dependencies Configuration.\par
Include the test_files directroy. \par
Insert the test records by running test_files/test_sql.txt.\par
Use Mock EJB for testing.\par
Execute \lquote ant test\rquote  within the directory that the distribution was extracted to.\par
\par
\pard\nowidctlpar\tx0\b 4.2Required steps to use the component\par
\pard\nowidctlpar\li720\b0 Configure the dependency components. \par
\pard\nowidctlpar\sa120\par
\pard\nowidctlpar\tx0\b 4.3 Demo\par
\pard\nowidctlpar\b0\par
We will assume here that everything is configured properly.  Try/catch clauses have been removed to enhance clarity.\par
\cf2\i\par
\i0 // Create a FixedBillingEntryManagerDelegate\par
FixedBillingEntryManager entryManager = new FixedBillingEntryManagerDelegate("applicationNamespace");\par
\par
FixedBillingEntry newEntry = new FixedBillingEntry();\par
newEntry.setCompanyId(tcCompanyId);\par
newEntry.setDescription("Dinner");\par
newEntry.setEntryDate(new Date());\par
newEntry.setStatus(pendingStatus);\par
\par
\b //1.The demo of FixedBillingEntryManager with single FixedBillingEntry.\b0\par
// Register the entry with the manager, with auditing.\par
entryManager.createFixedBillingEntry(newEntry, true);\par
\par
//Register the entry with the manager, with auditing.\par
entryManager.createFixedBillingEntry(entries[0], true);\par
\par
FixedBillingEntry changingEntry = entryManager.getFixedBillingEntry(entries[0].getId());\par
changingEntry.setDescription("Purchase Replacement Parts");\par
entryManager.updateFixedBillingEntry(changingEntry, true);\par
//Add a RejectReason to the Entry\par
entryManager.addRejectReasonToEntry(changingEntry, 100, true);\par
\par
FixedBillingEntryFilterFactory filterFactory = entryManager.getFixedBillingEntryFilterFactory();\par
List criteria = new ArrayList();\par
criteria.add(filterFactory.createDescriptionFilter("Purchase", StringMatchType.SUBSTRING));\par
criteria.add(filterFactory.createCreationUserFilter("user0", StringMatchType.EXACT_MATCH));\par
\par
//Create a search filter that aggregates the criteria.\par
Filter searchFilter = new AndFilter(criteria);\par
FixedBillingEntry[] matchingEntries = entryManager.searchFixedBillingEntries(searchFilter);\par
assertEquals("The return value should be same.", 1, matchingEntries.length);\par
//Delete the users; auditing is performed.\par
entryManager.deleteFixedBillingEntry(matchingEntries[0].getId(), true);\par
\par
\b //2.The demo of FixedBillingEntryManager with FixedBillingEntry array.\b0\par
entryManager.createFixedBillingEntries(entries, true);\par
\par
FixedBillingEntry[] changingEntries = entryManager.getFixedBillingEntries(new long[] \{\par
                  entries[0].getId(), entries[1].getId(), entries[2].getId()\par
\});\par
changingEntries[0].setDescription("Purchase Replacement Parts");\par
entryManager.updateFixedBillingEntries(changingEntries, true);\par
entryManager.addRejectReasonToEntry(changingEntries[0], 100, true);\par
\par
long[] rejectReasonIds = entryManager.getAllRejectReasonsForEntry(changingEntries[0]);\par
\par
//A for loop will be used to feed the rejectReasonIds singularly.  The application container\par
//will take care of rolling back any failed transactions.\par
for (int x = 0; x < rejectReasonIds.length; x++) \{\par
       entryManager.removeRejectReasonFromEntry(changingEntries[0], 100, true);\par
\}\par
\par
entryManager.deleteFixedBillingEntries(new long[] \{ entries[0].getId(), entries[1].getId(), entries[2].getId() \},\par
            true);\par
\par
\b //3. The demo of FixedBillingStatusManager with single FixedBillingStatus.\b0\par
//Create the status in the manager.\par
statusManager.createFixedBillingStatus(statuses[0]);\par
statuses[0].setDescription("Tentative Approval");\par
statusManager.updateFixedBillingStatus(statuses[0]);\par
\par
FixedBillingStatusFilterFactory statusFilterFactory = statusManager.getFixedBillingStatusFilterFactory();\par
FixedBillingStatus statusResults = statusManager.searchFixedBillingStatuses(statusFilterFactory.createDescriptionFilter(\par
                   "Tentative Approval", StringMatchType.EXACT_MATCH));\par
statusManager.deleteFixedBillingStatus(statusResults.getId());\par
\par
\b //4.The demo of FixedBillingStatusManager with FixedBillingStatus array.\b0\par
statusManager.createFixedBillingStatuses(statuses);\par
statuses[0].setDescription("Tentative Approval");\par
statusManager.updateFixedBillingStatuses(statuses);\par
statusManager.getFixedBillingStatuses(new long[] \{ statuses[0].getId(), statuses[1].getId() \});\par
statusManager.getAllFixedBillingStatuses();\par
statusManager.deleteFixedBillingStatuses(new long[] \{ statuses[0].getId(), statuses[1].getId() \});\par
\par
\pard\keepn\nowidctlpar\sb120\sa60\sl240\slmult0\tx0\tx77\b\fs24 5.Future Enhancements\b0\par
\pard\nowidctlpar\li750\sa120\fs20 Provide implementations for different RDBMS.  \par
}
 